<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ç¬¦æ–‡æ³•å¸ˆ - Glyph Caster</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #0a0a0a;
            overflow: hidden;
            touch-action: none;
            font-family: Arial, sans-serif;
        }
        
        #gameCanvas {
            display: block;
            background: radial-gradient(circle at center, #1a1a2e 0%, #0a0a0a 100%);
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            font-size: 18px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        
        .ui-element {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
        }
        
        .mana-bar {
            width: 200px;
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #4a90e2;
            border-radius: 10px;
            overflow: hidden;
            margin-left: 10px;
        }
        
        .mana-fill {
            height: 100%;
            background: linear-gradient(to right, #4a90e2, #7bb3f0);
            transition: width 0.3s ease;
            box-shadow: 0 0 10px #4a90e2;
        }
        
        /* æŠ€èƒ½æ æ ·å¼ */
        #skillBar {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            gap: 10px;
            display: none;
        }
        
        .skill-icon {
            width: 60px;
            height: 60px;
            border: 2px solid #4a90e2;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 12px;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .skill-icon:hover {
            background: rgba(0, 0, 0, 0.9);
            transform: scale(1.05);
        }
        
        .skill-icon.on-cooldown {
            border-color: #666;
            background: rgba(0, 0, 0, 0.9);
            cursor: not-allowed;
        }
        
        .skill-icon.low-mana {
            border-color: #ff6b6b;
            background: rgba(255, 107, 107, 0.2);
        }
        
        .cooldown-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #ff6b6b;
            font-weight: bold;
            font-size: 14px;
            border-radius: 8px;
        }
        
        .skill-emoji {
            font-size: 24px;
            margin-bottom: 2px;
        }
        
        .mana-cost {
            font-size: 10px;
            color: #4a90e2;
            margin-top: 2px;
        }
        
        .skill-name {
            font-size: 8px;
            color: #ccc;
            text-align: center;
        }
        
        #helpButton {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 10px 20px;
            background: rgba(74, 144, 226, 0.3);
            color: #fff;
            border: 2px solid #4a90e2;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        
        #helpButton:hover {
            background: rgba(74, 144, 226, 0.5);
        }
        
        #gameOver, #helpScreen, #upgradeScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #fff;
            display: none;
            background: rgba(0, 0, 0, 1.0);
            padding: 30px;
            border-radius: 10px;
            border: 2px solid #4a90e2;
            max-width: 90%;
            max-height: 95%;
            overflow-y: auto;
        }
        
        #gameOver h2, #helpScreen h2, #upgradeScreen h2 {
            font-size: 36px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
        }
        
        button {
            padding: 15px 30px;
            font-size: 20px;
            background: #4a90e2;
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(74, 144, 226, 0.5);
            margin: 10px;
        }
        
        button:hover {
            background: #5ba0f2;
        }
        
        .glyph-guide {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }
        
        .glyph-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            width: 200px;
        }
        
        .glyph-item canvas {
            width: 100%;
            height: 80px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            margin-bottom: 10px;
        }
        
        .glyph-name {
            font-size: 18px;
            color: #4a90e2;
            margin-bottom: 5px;
        }
        
        .glyph-desc {
            font-size: 14px;
            color: #ccc;
        }
        
        .upgrade-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin: 20px 0;
        }
        
        .upgrade-option {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
        }
        
        .upgrade-option:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: #4a90e2;
            transform: scale(1.02);
        }
        
        .upgrade-title {
            font-size: 20px;
            color: #4a90e2;
            margin-bottom: 10px;
        }
        
        .upgrade-desc {
            font-size: 16px;
            color: #ccc;
        }
        
        #startScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #fff;
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 10px;
            border: 2px solid #4a90e2;
        }
        
        #startScreen h1 {
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 30px rgba(74, 144, 226, 0.8);
        }
        
        #startScreen p {
            font-size: 18px;
            margin-bottom: 30px;
            color: #ccc;
        }
        
        /* æ–°å¢ï¼šå•ç‹¬è°ƒæ•´#helpScreenæœ€å¤§å®½åº¦å’Œéšè—Yè½´æ»šåŠ¨æ¡ */
        #helpScreen {
            max-width: 900px;
            overflow-y: hidden;
            width: 80%;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui" style="display: none;">
        <div class="ui-element">
            <span>åˆ†æ•°: <span id="score">0</span></span>
        </div>
        <div class="ui-element">
            <span>æ³¢æ¬¡: <span id="wave">1</span></span>
        </div>
        <div class="ui-element">
            <span>æ³•åŠ›å€¼:</span>
            <div class="mana-bar">
                <div class="mana-fill" id="manaFill"></div>
            </div>
        </div>
    </div>
    
    <!-- æŠ€èƒ½æ  -->
    <div id="skillBar">
        <div class="skill-icon" data-skill="line">
            <div class="skill-emoji">ğŸ”¥</div>
            <div class="skill-name">ç«çƒ</div>
            <div class="mana-cost">10</div>
        </div>
        <div class="skill-icon" data-skill="circle">
            <div class="skill-emoji">ğŸ›¡ï¸</div>
            <div class="skill-name">æŠ¤ç›¾</div>
            <div class="mana-cost">30</div>
        </div>
        <div class="skill-icon" data-skill="triangle">
            <div class="skill-emoji">ğŸ¯</div>
            <div class="skill-name">è¿½è¸ª</div>
            <div class="mana-cost">20</div>
        </div>
        <div class="skill-icon" data-skill="z">
            <div class="skill-emoji">âš¡</div>
            <div class="skill-name">é—ªç”µ</div>
            <div class="mana-cost">40</div>
        </div>
        <div class="skill-icon" data-skill="spiral">
            <div class="skill-emoji">ğŸŒ€</div>
            <div class="skill-name">æ—‹æ¶¡</div>
            <div class="mana-cost">50</div>
        </div>
    </div>
    
    <button id="helpButton" style="display: none;" onclick="showHelp()">æ¸¸æˆè¯´æ˜</button>
    
    <div id="startScreen">
        <h1>ç¬¦æ–‡æ³•å¸ˆ</h1>
        <p>åœ¨å±å¹•ä¸Šç»˜åˆ¶ç¥ç§˜ç¬¦æ–‡ï¼Œé‡Šæ”¾å¼ºå¤§é­”æ³•ï¼</p>
        <button onclick="startGame()">å¼€å§‹æ¸¸æˆ</button>
        <button onclick="showHelp()">æ¸¸æˆè¯´æ˜</button>
    </div>
    
    <div id="helpScreen">
        <h2>æ¸¸æˆè¯´æ˜</h2>
        <h3 style="color: #4a90e2; margin: 20px 0;">åŸºç¡€ç©æ³•</h3>
        <p style="margin-bottom: 20px;">åœ¨å±å¹•ä¸Šç»˜åˆ¶ä¸åŒçš„ç¬¦æ–‡å›¾æ¡ˆæ¥é‡Šæ”¾å¯¹åº”çš„é­”æ³•ã€‚æ•Œäººä¼šä»å››é¢å…«æ–¹æ¶Œæ¥ï¼Œä½¿ç”¨ä½ çš„é­”æ³•æ¶ˆç­å®ƒä»¬ï¼</p>
        
        <h3 style="color: #4a90e2; margin: 20px 0;">ç¬¦æ–‡ç³»ç»Ÿ</h3>
        <div class="glyph-guide" id="glyphGuide"></div>
        
        <h3 style="color: #4a90e2; margin: 20px 0;">æ¸¸æˆæœºåˆ¶</h3>
        <ul style="text-align: left; margin: 0 auto; max-width: 400px;">
            <li>æ¶ˆç­æ•Œäººè·å¾—åˆ†æ•°å’Œæ³•åŠ›å€¼</li>
            <li>æ³•åŠ›å€¼ä¼šç¼“æ…¢è‡ªåŠ¨æ¢å¤</li>
            <li>æ¯æ³¢æ•Œäººæ¶ˆç­åå¯é€‰æ‹©ä¸€ä¸ªå¼ºåŒ–</li>
            <li>è¢«æ•Œäººç¢°åˆ°ä¼šæŸå¤±æŠ¤ç›¾æˆ–æ¸¸æˆç»“æŸ</li>
        </ul>
        
        <button onclick="hideHelp()">å…³é—­</button>
    </div>
    
    <div id="upgradeScreen">
        <h2>é€‰æ‹©ä½ çš„å¼ºåŒ–</h2>
        <p style="margin-bottom: 20px;">æˆåŠŸé˜²å¾¡äº†ä¸€æ³¢æ”»å‡»ï¼é€‰æ‹©ä¸€ä¸ªå¼ºåŒ–ç»§ç»­æˆ˜æ–—ï¼š</p>
        <div class="upgrade-options" id="upgradeOptions"></div>
    </div>
    
    <div id="gameOver">
        <h2>æ¸¸æˆç»“æŸ</h2>
        <p>æœ€ç»ˆåˆ†æ•°: <span id="finalScore">0</span></p>
        <p>ç”Ÿå­˜æ³¢æ¬¡: <span id="finalWave">0</span></p>
        <button onclick="location.reload()">é‡æ–°å¼€å§‹</button>
    </div>

    <script>
        // æ¸¸æˆé…ç½®
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // è®¾ç½®ç”»å¸ƒå¤§å°
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // æ¸¸æˆçŠ¶æ€
        const game = {
            score: 0,
            wave: 1,
            mana: 100,
            maxMana: 100,
            manaRegen: 0.2,
            isDrawing: false,
            currentGlyph: [],
            enemies: [],
            projectiles: [],
            effects: [],
            vortexes: [], // æ–°å¢ï¼šæ—‹æ¶¡æ•°ç»„
            player: {
                x: canvas.width / 2,
                y: canvas.height / 2,
                radius: 30,
                shield: 0,
                shieldMax: 3
            },
            isPaused: false,
            isGameOver: false,
            hasStarted: false,
            upgrades: {
                fireballExplosion: false,
                shieldPush: false,
                chainLightningExtra: 0,
                manaRegenBonus: 0,
                fireballSize: 1,
                shieldDuration: 1,
                projectileSpeed: 1,
                manaCostReduction: 0
            }
        };
        
        // ç¬¦æ–‡æ¨¡æ¿
        const glyphTemplates = {
            line: {
                name: 'ç«çƒæœ¯',
                description: 'å‘æŒ‡å®šæ–¹å‘å‘å°„ç«çƒ',
                color: '#ff6b6b',
                manaCost: 10,
                cooldown: 0,
                lastUsed: 0,
                pattern: 'line'
            },
            circle: {
                name: 'é­”æ³•æŠ¤ç›¾',
                description: 'ç”Ÿæˆä¿æŠ¤æŠ¤ç›¾',
                color: '#4ecdc4',
                manaCost: 30,
                cooldown: 5000,
                lastUsed: 0,
                pattern: 'circle'
            },
            triangle: {
                name: 'è¿½è¸ªé£å¼¹',
                description: 'å‘å°„è‡ªåŠ¨è¿½è¸ªçš„é£å¼¹',
                color: '#ffe66d',
                manaCost: 20,
                cooldown: 1000,
                lastUsed: 0,
                pattern: 'triangle'
            },
            z: {
                name: 'è¿é”é—ªç”µ',
                description: 'åœ¨æ•Œäººé—´è·³è·ƒçš„é—ªç”µ',
                color: '#a8e6cf',
                manaCost: 40,
                cooldown: 3000,
                lastUsed: 0,
                pattern: 'z'
            },
            spiral: {
                name: 'å¼•åŠ›æ—‹æ¶¡',
                description: 'åˆ›é€ å¸å¼•æ•Œäººçš„æ—‹æ¶¡',
                color: '#c7ceea',
                manaCost: 50,
                cooldown: 8000,
                lastUsed: 0,
                pattern: 'spiral'
            }
        };
        
        // å¯èƒ½çš„å‡çº§é€‰é¡¹
        const possibleUpgrades = [
            {
                id: 'fireballExplosion',
                title: 'çˆ†ç‚¸ç«çƒ',
                description: 'ä½ çš„ç«çƒæœ¯å‡»ä¸­ç›®æ ‡åä¼šäº§ç”Ÿå°èŒƒå›´çˆ†ç‚¸',
                apply: () => { game.upgrades.fireballExplosion = true; }
            },
            {
                id: 'shieldPush',
                title: 'åå‡»æŠ¤ç›¾',
                description: 'é­”æ³•æŠ¤ç›¾è¢«å‡»ç ´æ—¶ä¼šæ¨å¼€å‘¨å›´çš„æ•Œäºº',
                apply: () => { game.upgrades.shieldPush = true; }
            },
            {
                id: 'chainLightningExtra',
                title: 'å¼ºåŒ–é—ªç”µ',
                description: 'è¿é”é—ªç”µå¯ä»¥å¤šå¼¹è·³2æ¬¡',
                apply: () => { game.upgrades.chainLightningExtra += 2; }
            },
            {
                id: 'manaRegenBonus',
                title: 'æ³•åŠ›æ¶Œæµ',
                description: 'æ³•åŠ›æ¢å¤é€Ÿåº¦æå‡50%',
                apply: () => { 
                    game.upgrades.manaRegenBonus += 0.5;
                    game.manaRegen *= 1.5;
                }
            },
            {
                id: 'fireballSize',
                title: 'å·¨å‹ç«çƒ',
                description: 'ç«çƒä½“ç§¯å’Œä¼¤å®³å¢åŠ 30%',
                apply: () => { game.upgrades.fireballSize *= 1.3; }
            },
            {
                id: 'maxManaBonus',
                title: 'æ³•åŠ›æ‰©å±•',
                description: 'æœ€å¤§æ³•åŠ›å€¼å¢åŠ 30ç‚¹',
                apply: () => { 
                    game.maxMana += 30;
                    game.mana += 30;
                }
            },
            {
                id: 'projectileSpeed',
                title: 'ç–¾é€Ÿæ–½æ³•',
                description: 'æ‰€æœ‰æŠ•å°„ç‰©é€Ÿåº¦æå‡30%',
                apply: () => { game.upgrades.projectileSpeed *= 1.3; }
            },
            {
                id: 'manaCostReduction',
                title: 'èŠ‚èƒ½æ–½æ³•',
                description: 'æ‰€æœ‰æ³•æœ¯æ¶ˆè€—å‡å°‘20%',
                apply: () => { game.upgrades.manaCostReduction += 0.2; }
            },
            {
                id: 'triangleCount',
                title: 'å¤šé‡è¿½è¸ª',
                description: 'è¿½è¸ªé£å¼¹æ•°é‡+2',
                apply: () => { game.upgrades.triangleCount = (game.upgrades.triangleCount || 0) + 2; }
            },
            {
                id: 'vortexDamage',
                title: 'ç ´åæ—‹æ¶¡',
                description: 'å¼•åŠ›æ—‹æ¶¡å¯¹æ•Œäººé€ æˆæŒç»­ä¼¤å®³',
                apply: () => { game.upgrades.vortexDamage = true; }
            }
        ];
        
        // æ•Œäººç±»å‹
        const enemyTypes = {
            imp: {
                radius: 15,
                speed: 1.5,
                health: 1,
                color: '#ff6b6b',
                score: 10
            },
            brute: {
                radius: 25,
                speed: 0.5,
                health: 5,
                color: '#ff4757',
                score: 30
            },
            wraith: {
                radius: 12,
                speed: 3,
                health: 1,
                color: '#dfe6e9',
                score: 20
            },
            swarm: {
                radius: 8,
                speed: 2,
                health: 1,
                color: '#fdcb6e',
                score: 5
            }
        };
        
        // ç²’å­æ•ˆæœç±»
        class Particle {
            constructor(x, y, color, velocity, lifetime = 1000) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.velocity = velocity;
                this.lifetime = lifetime;
                this.age = 0;
                this.radius = Math.random() * 3 + 1;
            }
            
            update(deltaTime) {
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                this.age += deltaTime;
                this.velocity.x *= 0.98;
                this.velocity.y *= 0.98;
                return this.age < this.lifetime;
            }
            
            draw() {
                const alpha = 1 - (this.age / this.lifetime);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }
        
        // æ—‹æ¶¡ç±»
        class Vortex {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 80;
                this.strength = 2;
                this.lifetime = 5000;
                this.age = 0;
                this.rotation = 0;
            }
            
            update(deltaTime) {
                this.age += deltaTime;
                this.rotation += 0.1;
                
                // å½±å“èŒƒå›´å†…çš„æ•Œäºº
                game.enemies.forEach(enemy => {
                    const dx = this.x - enemy.x;
                    const dy = this.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < this.radius) {
                        const force = this.strength * (1 - distance / this.radius);
                        enemy.x += (dx / distance) * force;
                        enemy.y += (dy / distance) * force;
                        
                        // æ—‹è½¬æ•ˆæœ
                        const angle = Math.atan2(dy, dx);
                        const tangentX = -Math.sin(angle);
                        const tangentY = Math.cos(angle);
                        enemy.x += tangentX * force * 0.5;
                        enemy.y += tangentY * force * 0.5;
                        
                        // å¦‚æœæœ‰ç ´åæ—‹æ¶¡å‡çº§ï¼Œé€ æˆä¼¤å®³
                        if (game.upgrades.vortexDamage && Math.random() < 0.02) {
                            if (enemy.takeDamage(1)) {
                                game.enemies = game.enemies.filter(e => e !== enemy);
                            }
                        }
                    }
                });
                
                return this.age < this.lifetime;
            }
            
            draw() {
                const alpha = 1 - (this.age / this.lifetime);
                ctx.globalAlpha = alpha * 0.3;
                
                // ç»˜åˆ¶æ—‹æ¶¡
                ctx.strokeStyle = glyphTemplates.spiral.color;
                ctx.lineWidth = 3;
                
                for (let i = 0; i < 5; i++) {
                    const r = this.radius * (i + 1) / 5;
                    ctx.beginPath();
                    
                    for (let angle = 0; angle < Math.PI * 4; angle += 0.1) {
                        const spiralR = r * (1 - angle / (Math.PI * 4));
                        const x = this.x + Math.cos(angle + this.rotation) * spiralR;
                        const y = this.y + Math.sin(angle + this.rotation) * spiralR;
                        
                        if (angle === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                }
                
                ctx.globalAlpha = 1;
            }
        }
        
        // æ•Œäººç±»
        class Enemy {
            constructor(type, x, y) {
                this.type = type;
                this.x = x;
                this.y = y;
                this.radius = enemyTypes[type].radius;
                this.speed = enemyTypes[type].speed;
                this.health = enemyTypes[type].health;
                this.maxHealth = enemyTypes[type].health;
                this.color = enemyTypes[type].color;
                this.score = enemyTypes[type].score;
            }
            
            update() {
                const dx = game.player.x - this.x;
                const dy = game.player.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    this.x += (dx / distance) * this.speed;
                    this.y += (dy / distance) * this.speed;
                }
                
                // æ£€æŸ¥ä¸ç©å®¶çš„ç¢°æ’
                if (distance < this.radius + game.player.radius) {
                    this.takeDamage(this.health);
                    if (game.player.shield > 0) {
                        game.player.shield--;
                        if (game.upgrades.shieldPush) {
                            // æŠ¤ç›¾åå‡»
                            this.x = game.player.x + (dx / distance) * 100;
                            this.y = game.player.y + (dy / distance) * 100;
                        }
                    } else {
                        game.isGameOver = true;
                    }
                }
            }
            
            takeDamage(damage) {
                this.health -= damage;
                if (this.health <= 0) {
                    game.score += this.score;
                    const manaGain = game.upgrades.killManaBonus ? 10 : 5;
                    game.mana = Math.min(game.mana + manaGain, game.maxMana);
                    createExplosion(this.x, this.y, this.color);
                    return true;
                }
                return false;
            }
            
            draw() {
                // ç»˜åˆ¶æ•Œäºº
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.stroke();
                
                // ç»˜åˆ¶è¡€æ¡
                if (this.health < this.maxHealth) {
                    const barWidth = this.radius * 2;
                    const barHeight = 4;
                    const barY = this.y - this.radius - 10;
                    
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.fillRect(this.x - barWidth/2, barY, barWidth, barHeight);
                    
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x - barWidth/2, barY, barWidth * (this.health / this.maxHealth), barHeight);
                }
            }
        }
        
        // æŠ•å°„ç‰©ç±»
        class Projectile {
            constructor(x, y, target, type, damage = 1) {
                this.x = x;
                this.y = y;
                this.target = target;
                this.type = type;
                this.damage = damage * (type === 'line' ? game.upgrades.fireballSize : 1);
                this.speed = 8 * game.upgrades.projectileSpeed;
                this.radius = 5 * (type === 'line' ? game.upgrades.fireballSize : 1);
                this.trail = [];
                this.isHomingMissile = (type === 'triangle');
            }
            
            update() {
                this.trail.push({x: this.x, y: this.y});
                if (this.trail.length > 10) {
                    this.trail.shift();
                }
                
                // è¿½è¸ªé£å¼¹é‡æ–°å¯»æ‰¾ç›®æ ‡
                if (this.isHomingMissile && (!this.target || !game.enemies.includes(this.target))) {
                    this.target = findNearestEnemy(this.x, this.y);
                }
                
                if (this.target) {
                    const dx = this.target.x - this.x;
                    const dy = this.target.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < this.radius + this.target.radius) {
                        // å‘½ä¸­ç›®æ ‡
                        if (this.target.takeDamage(this.damage)) {
                            game.enemies = game.enemies.filter(e => e !== this.target);
                        }
                        
                        // ç«çƒçˆ†ç‚¸æ•ˆæœ
                        if (this.type === 'line' && game.upgrades.fireballExplosion) {
                            const explosionRadius = 50;
                            game.enemies.forEach(enemy => {
                                const dx = enemy.x - this.x;
                                const dy = enemy.y - this.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist < explosionRadius && enemy !== this.target) {
                                    if (enemy.takeDamage(1)) {
                                        game.enemies = game.enemies.filter(e => e !== enemy);
                                    }
                                }
                            });
                            createExplosion(this.x, this.y, '#ff9999');
                        }
                        
                        return false;
                    }
                    
                    this.x += (dx / distance) * this.speed;
                    this.y += (dy / distance) * this.speed;
                } else {
                    // æ²¡æœ‰ç›®æ ‡ï¼Œç›´çº¿é£è¡Œ
                    this.x += Math.cos(this.angle || 0) * this.speed;
                    this.y += Math.sin(this.angle || 0) * this.speed;
                }
                
                // æ£€æŸ¥æ˜¯å¦è¶…å‡ºå±å¹•
                return this.x > 0 && this.x < canvas.width && 
                       this.y > 0 && this.y < canvas.height;
            }
            
            draw() {
                // ç»˜åˆ¶è½¨è¿¹
                ctx.strokeStyle = glyphTemplates[this.type].color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                this.trail.forEach((point, index) => {
                    if (index === 0) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                });
                ctx.lineTo(this.x, this.y);
                ctx.stroke();
                
                // ç»˜åˆ¶æŠ•å°„ç‰©
                ctx.fillStyle = glyphTemplates[this.type].color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // åˆ›å»ºçˆ†ç‚¸æ•ˆæœ
        function createExplosion(x, y, color) {
            for (let i = 0; i < 20; i++) {
                const angle = (Math.PI * 2 * i) / 20;
                const speed = Math.random() * 3 + 2;
                game.effects.push(new Particle(
                    x, y, color,
                    {
                        x: Math.cos(angle) * speed,
                        y: Math.sin(angle) * speed
                    }
                ));
            }
        }
        
        // æŸ¥æ‰¾æœ€è¿‘çš„æ•Œäºº
        function findNearestEnemy(x, y) {
            let nearest = null;
            let minDistance = Infinity;
            
            game.enemies.forEach(enemy => {
                const dx = enemy.x - x;
                const dy = enemy.y - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < minDistance) {
                    minDistance = distance;
                    nearest = enemy;
                }
            });
            
            return nearest;
        }
        
        // ==================== æ”¹è¿›çš„ç¬¦æ–‡è¯†åˆ«ç®—æ³• ====================
        
        // æ”¹è¿›çš„åœ†å½¢æ£€æµ‹
        function isCircleShape(points) {
            if (points.length < 20) return false;
            
            // æ£€æŸ¥èµ·ç‚¹å’Œç»ˆç‚¹æ˜¯å¦æ¥è¿‘ï¼ˆé—­åˆæ€§æ£€æŸ¥ï¼‰
            const firstPoint = points[0];
            const lastPoint = points[points.length - 1];
            const closureDistance = Math.sqrt(
                Math.pow(lastPoint.x - firstPoint.x, 2) + 
                Math.pow(lastPoint.y - firstPoint.y, 2)
            );
            
            // è®¡ç®—æ€»è·¯å¾„é•¿åº¦
            let totalLength = 0;
            for (let i = 1; i < points.length; i++) {
                const dx = points[i].x - points[i-1].x;
                const dy = points[i].y - points[i-1].y;
                totalLength += Math.sqrt(dx * dx + dy * dy);
            }
            
            // é—­åˆæ€§æ£€æŸ¥ï¼šèµ·ç‚¹ç»ˆç‚¹è·ç¦»åº”è¯¥å°äºæ€»é•¿åº¦çš„10%
            if (closureDistance > totalLength * 0.1) return false;
            
            // è®¡ç®—ä¸­å¿ƒç‚¹
            const centerX = points.reduce((sum, p) => sum + p.x, 0) / points.length;
            const centerY = points.reduce((sum, p) => sum + p.y, 0) / points.length;
            
            // è®¡ç®—å¹³å‡åŠå¾„
            const avgRadius = points.reduce((sum, p) => {
                const dx = p.x - centerX;
                const dy = p.y - centerY;
                return sum + Math.sqrt(dx * dx + dy * dy);
            }, 0) / points.length;
            
            // è®¡ç®—åŠå¾„æ–¹å·®
            const radiusVariance = points.reduce((sum, p) => {
                const dx = p.x - centerX;
                const dy = p.y - centerY;
                const radius = Math.sqrt(dx * dx + dy * dy);
                return sum + Math.abs(radius - avgRadius);
            }, 0) / points.length;
            
            // æ£€æŸ¥è§’åº¦åˆ†å¸ƒæ˜¯å¦å‡åŒ€ï¼ˆåœ†å½¢ç‰¹å¾ï¼‰
            const angles = points.map(p => Math.atan2(p.y - centerY, p.x - centerX));
            angles.sort((a, b) => a - b);
            
            let angleSpread = 0;
            for (let i = 1; i < angles.length; i++) {
                let diff = angles[i] - angles[i-1];
                if (diff > Math.PI) diff = 2 * Math.PI - diff;
                angleSpread += diff;
            }
            
            // åœ†å½¢åˆ¤æ–­æ¡ä»¶
            return radiusVariance < avgRadius * 0.25 && // åŠå¾„å˜åŒ–å°
                   angleSpread > Math.PI * 1.5 && // è§’åº¦è¦†ç›–è¶³å¤Ÿ
                   avgRadius > 20; // æœ€å°åŠå¾„
        }
        
        // æ”¹è¿›çš„ä¸‰è§’å½¢æ£€æµ‹
        function isTriangleShape(points) {
            if (points.length < 15) return false;
            
            // æ£€æŸ¥é—­åˆæ€§
            const firstPoint = points[0];
            const lastPoint = points[points.length - 1];
            const closureDistance = Math.sqrt(
                Math.pow(lastPoint.x - firstPoint.x, 2) + 
                Math.pow(lastPoint.y - firstPoint.y, 2)
            );
            
            let totalLength = 0;
            for (let i = 1; i < points.length; i++) {
                const dx = points[i].x - points[i-1].x;
                const dy = points[i].y - points[i-1].y;
                totalLength += Math.sqrt(dx * dx + dy * dy);
            }
            
            // å¿…é¡»æ˜¯ç›¸å¯¹é—­åˆçš„å½¢çŠ¶
            if (closureDistance > totalLength * 0.15) return false;
            
            // å¯»æ‰¾è§’ç‚¹ï¼ˆæ–¹å‘æ˜¾è‘—å˜åŒ–çš„ç‚¹ï¼‰
            const corners = [];
            const threshold = Math.PI / 2.5; // çº¦72åº¦
            
            for (let i = 8; i < points.length - 8; i++) {
                const before = points[i - 8];
                const current = points[i];
                const after = points[i + 8];
                
                const angle1 = Math.atan2(current.y - before.y, current.x - before.x);
                const angle2 = Math.atan2(after.y - current.y, after.x - current.x);
                
                let angleDiff = Math.abs(angle2 - angle1);
                if (angleDiff > Math.PI) angleDiff = Math.PI * 2 - angleDiff;
                
                if (angleDiff > threshold) {
                    // æ£€æŸ¥è¿™ä¸ªè§’ç‚¹æ˜¯å¦ä¸ä¹‹å‰çš„è§’ç‚¹è·ç¦»è¶³å¤Ÿè¿œ
                    let isFarEnough = true;
                    for (const corner of corners) {
                        const dist = Math.sqrt(
                            Math.pow(corner.x - current.x, 2) + 
                            Math.pow(corner.y - current.y, 2)
                        );
                        if (dist < 40) {
                            isFarEnough = false;
                            break;
                        }
                    }
                    if (isFarEnough) {
                        corners.push(current);
                    }
                }
            }
            
            // ä¸‰è§’å½¢åº”è¯¥æœ‰2-4ä¸ªè§’ç‚¹
            return corners.length >= 2 && corners.length <= 4;
        }
        
        // æ”¹è¿›çš„Zå­—å½¢æ£€æµ‹
        function isZShape(points) {
            if (points.length < 25) return false;
            
            const firstPoint = points[0];
            const lastPoint = points[points.length - 1];
            
            // Zå½¢åŸºæœ¬ç‰¹å¾æ£€æŸ¥
            const totalHorizontal = Math.abs(lastPoint.x - firstPoint.x);
            const totalVertical = Math.abs(lastPoint.y - firstPoint.y);
            
            // Zå½¢åº”è¯¥æœ‰æ˜æ˜¾çš„æ°´å¹³å»¶ä¼¸
            if (totalHorizontal < 60 || totalVertical < 30) return false;
            
            // å°†è·¯å¾„åˆ†æˆä¸‰æ®µåˆ†æ
            const segment1End = Math.floor(points.length * 0.33);
            const segment2End = Math.floor(points.length * 0.67);
            
            const segment1 = points.slice(0, segment1End);
            const segment2 = points.slice(segment1End, segment2End);
            const segment3 = points.slice(segment2End);
            
            // è®¡ç®—æ¯æ®µçš„ä¸»è¦æ–¹å‘
            function getSegmentDirection(segment) {
                const start = segment[0];
                const end = segment[segment.length - 1];
                return Math.atan2(end.y - start.y, end.x - start.x);
            }
            
            const dir1 = getSegmentDirection(segment1);
            const dir2 = getSegmentDirection(segment2);
            const dir3 = getSegmentDirection(segment3);
            
            // æ£€æŸ¥Zå½¢çš„ç‰¹å¾ï¼šç¬¬ä¸€æ®µå’Œç¬¬ä¸‰æ®µåº”è¯¥æ–¹å‘ç›¸ä¼¼ï¼Œç¬¬äºŒæ®µæ–¹å‘ä¸åŒ
            function normalizeAngle(angle) {
                while (angle > Math.PI) angle -= 2 * Math.PI;
                while (angle <= -Math.PI) angle += 2 * Math.PI;
                return angle;
            }
            
            const diff1_3 = Math.abs(normalizeAngle(dir1 - dir3));
            const diff1_2 = Math.abs(normalizeAngle(dir1 - dir2));
            const diff2_3 = Math.abs(normalizeAngle(dir2 - dir3));
            
            // Zå½¢ç‰¹å¾ï¼šç¬¬ä¸€æ®µå’Œç¬¬ä¸‰æ®µæ–¹å‘ç›¸ä¼¼ï¼Œä¸ç¬¬äºŒæ®µæ–¹å‘å·®å¼‚å¤§
            const isValidZ = (diff1_3 < Math.PI / 3) && // ç¬¬ä¸€æ®µå’Œç¬¬ä¸‰æ®µæ–¹å‘ç›¸ä¼¼
                             (diff1_2 > Math.PI / 4) && // ç¬¬ä¸€æ®µå’Œç¬¬äºŒæ®µæ–¹å‘ä¸åŒ
                             (diff2_3 > Math.PI / 4);   // ç¬¬äºŒæ®µå’Œç¬¬ä¸‰æ®µæ–¹å‘ä¸åŒ
            
            return isValidZ;
        }
        
        // èºæ—‹å½¢æ£€æµ‹ï¼ˆä¿æŒåŸæœ‰ç®—æ³•ï¼‰
        function isSpiralShape(points) {
            if (points.length < 30) return false;
            
            // è®¡ç®—ä¸­å¿ƒç‚¹
            const centerX = points.reduce((sum, p) => sum + p.x, 0) / points.length;
            const centerY = points.reduce((sum, p) => sum + p.y, 0) / points.length;
            
            let totalAngleChange = 0;
            let previousAngle = Math.atan2(points[0].y - centerY, points[0].x - centerX);
            
            for (let i = 1; i < points.length; i++) {
                const currentAngle = Math.atan2(points[i].y - centerY, points[i].x - centerX);
                let angleDiff = currentAngle - previousAngle;
                
                // å¤„ç†è§’åº¦è·³è·ƒ
                if (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                if (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                
                totalAngleChange += angleDiff;
                previousAngle = currentAngle;
            }
            
            // èºæ—‹å½¢åº”è¯¥æœ‰è‡³å°‘ä¸€åœˆçš„æ—‹è½¬
            return Math.abs(totalAngleChange) > Math.PI;
        }
        
        // æ›´æ–°ä¸»è¯†åˆ«å‡½æ•°
        function recognizeGlyph(points) {
            if (points.length < 5) return null;
            
            const firstPoint = points[0];
            const lastPoint = points[points.length - 1];
            
            // è®¡ç®—æ€»é•¿åº¦
            let totalLength = 0;
            for (let i = 1; i < points.length; i++) {
                const dx = points[i].x - points[i-1].x;
                const dy = points[i].y - points[i-1].y;
                totalLength += Math.sqrt(dx * dx + dy * dy);
            }
            
            // ä¼˜å…ˆæ£€æŸ¥å¤æ‚å½¢çŠ¶ï¼ŒæŒ‰è¯†åˆ«éš¾åº¦æ’åº
            if (isSpiralShape(points)) {
                return 'spiral';
            }
            
            if (isZShape(points)) {
                return 'z';
            }
            
            if (isCircleShape(points)) {
                return 'circle';
            }
            
            if (isTriangleShape(points)) {
                return 'triangle';
            }
            
            // ç›´çº¿æ£€æµ‹ï¼ˆæœ€å®½æ¾çš„æ¡ä»¶æ”¾æœ€åï¼‰
            const directDistance = Math.sqrt(
                Math.pow(lastPoint.x - firstPoint.x, 2) + 
                Math.pow(lastPoint.y - firstPoint.y, 2)
            );
            
            if (directDistance > 50 && totalLength < directDistance * 1.3) {
                return 'line';
            }
            
            return null;
        }
        
        // ==================== è¯†åˆ«ç®—æ³•ç»“æŸ ====================
        
        // æ›´æ–°æŠ€èƒ½å›¾æ ‡
        function updateSkillIcons() {
            const skillIcons = document.querySelectorAll('.skill-icon');
            const now = Date.now();
            
            skillIcons.forEach(icon => {
                const skillType = icon.getAttribute('data-skill');
                const glyph = glyphTemplates[skillType];
                if (!glyph) return;
                
                const actualManaCost = glyph.manaCost * (1 - game.upgrades.manaCostReduction);
                const cooldownRemaining = Math.max(0, glyph.cooldown - (now - glyph.lastUsed));
                
                // ç§»é™¤ä¹‹å‰çš„çŠ¶æ€ç±»
                icon.classList.remove('on-cooldown', 'low-mana');
                
                // æ¸…é™¤å†·å´å€’è®¡æ—¶æ˜¾ç¤º
                let cooldownOverlay = icon.querySelector('.cooldown-overlay');
                if (cooldownOverlay) {
                    cooldownOverlay.remove();
                }
                
                // æ£€æŸ¥å†·å´çŠ¶æ€
                if (cooldownRemaining > 0) {
                    icon.classList.add('on-cooldown');
                    cooldownOverlay = document.createElement('div');
                    cooldownOverlay.className = 'cooldown-overlay';
                    cooldownOverlay.textContent = Math.ceil(cooldownRemaining / 1000);
                    icon.appendChild(cooldownOverlay);
                }
                // æ£€æŸ¥æ³•åŠ›ä¸è¶³çŠ¶æ€
                else if (game.mana < actualManaCost) {
                    icon.classList.add('low-mana');
                }
                
                // æ›´æ–°æ³•åŠ›æ¶ˆè€—æ˜¾ç¤º
                const manaCostElement = icon.querySelector('.mana-cost');
                if (manaCostElement) {
                    manaCostElement.textContent = Math.ceil(actualManaCost);
                }
            });
        }
        
        // æ–½æ”¾æ³•æœ¯
        function castSpell(glyphType, endPoint) {
            const glyph = glyphTemplates[glyphType];
            const now = Date.now();
            
            // è®¡ç®—å®é™…æ³•åŠ›æ¶ˆè€—
            const actualManaCost = glyph.manaCost * (1 - game.upgrades.manaCostReduction);
            
            // æ£€æŸ¥æ³•åŠ›å€¼
            if (game.mana < actualManaCost) {
                showMessage('æ³•åŠ›ä¸è¶³ï¼', '#ff6b6b');
                return;
            }
            
            // æ£€æŸ¥å†·å´
            if (glyph.cooldown && now - glyph.lastUsed < glyph.cooldown) {
                showMessage('æŠ€èƒ½å†·å´ä¸­ï¼', '#ff6b6b');
                return;
            }
            
            game.mana -= actualManaCost;
            if (glyph.cooldown) {
                glyph.lastUsed = now;
            }
            
            switch(glyphType) {
                case 'line':
                    // ç«çƒæœ¯
                    const angle = Math.atan2(
                        endPoint.y - game.player.y,
                        endPoint.x - game.player.x
                    );
                    const projectile = new Projectile(
                        game.player.x,
                        game.player.y,
                        null,
                        'line',
                        2
                    );
                    projectile.angle = angle;
                    projectile.target = findNearestEnemy(
                        game.player.x + Math.cos(angle) * 100,
                        game.player.y + Math.sin(angle) * 100
                    );
                    game.projectiles.push(projectile);
                    break;
                    
                case 'circle':
                    // é­”æ³•æŠ¤ç›¾
                    game.player.shield = game.player.shieldMax;
                    createShieldEffect();
                    break;
                    
                case 'triangle':
                    // è¿½è¸ªé£å¼¹
                    const missileCount = 3 + (game.upgrades.triangleCount || 0);
                    for (let i = 0; i < missileCount; i++) {
                        const missile = new Projectile(
                            game.player.x,
                            game.player.y,
                            null,
                            'triangle',
                            1
                        );
                        // åˆå§‹éšæœºæ–¹å‘
                        missile.angle = (Math.PI * 2 * i) / missileCount;
                        game.projectiles.push(missile);
                    }
                    break;
                    
                case 'z':
                    // è¿é”é—ªç”µ
                    castChainLightning();
                    break;
                    
                case 'spiral':
                    // å¼•åŠ›æ—‹æ¶¡
                    game.vortexes.push(new Vortex(endPoint.x, endPoint.y));
                    break;
            }
            
            showMessage(glyph.name + '!', glyph.color);
        }
        
        // è¿é”é—ªç”µ
        function castChainLightning() {
            const maxJumps = 5 + game.upgrades.chainLightningExtra;
            const visited = new Set();
            let current = findNearestEnemy(game.player.x, game.player.y);
            let previous = game.player;
            
            if (!current) return;
            
            for (let i = 0; i < maxJumps && current; i++) {
                visited.add(current);
                
                // é€ æˆä¼¤å®³
                if (current.takeDamage(3)) {
                    game.enemies = game.enemies.filter(e => e !== current);
                }
                
                // ç»˜åˆ¶é—ªç”µæ•ˆæœ
                createLightningEffect(previous, current);
                
                // å¯»æ‰¾ä¸‹ä¸€ä¸ªç›®æ ‡
                let next = null;
                let minDistance = 200; // æœ€å¤§è·³è·ƒè·ç¦»
                
                game.enemies.forEach(enemy => {
                    if (!visited.has(enemy)) {
                        const dx = enemy.x - current.x;
                        const dy = enemy.y - current.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < minDistance) {
                            minDistance = distance;
                            next = enemy;
                        }
                    }
                });
                
                previous = current;
                current = next;
            }
        }
        
        // åˆ›å»ºé—ªç”µæ•ˆæœ
        function createLightningEffect(from, to) {
            const segments = 10;
            for (let i = 0; i < segments; i++) {
                const t = i / segments;
                const x = from.x + (to.x - from.x) * t + (Math.random() - 0.5) * 20;
                const y = from.y + (to.y - from.y) * t + (Math.random() - 0.5) * 20;
                
                game.effects.push(new Particle(
                    x, y,
                    glyphTemplates.z.color,
                    {x: 0, y: 0},
                    500
                ));
            }
        }
        
        // åˆ›å»ºæŠ¤ç›¾æ•ˆæœ
        function createShieldEffect() {
            const particles = 30;
            for (let i = 0; i < particles; i++) {
                const angle = (Math.PI * 2 * i) / particles;
                const radius = game.player.radius + 20;
                
                game.effects.push(new Particle(
                    game.player.x + Math.cos(angle) * radius,
                    game.player.y + Math.sin(angle) * radius,
                    glyphTemplates.circle.color,
                    {x: 0, y: 0},
                    2000
                ));
            }
        }
        
        // æ˜¾ç¤ºæ¶ˆæ¯
        function showMessage(text, color) {
            const message = {
                text: text,
                color: color,
                x: game.player.x,
                y: game.player.y - 50,
                age: 0,
                lifetime: 1000
            };
            game.effects.push(message);
        }
        
        // æ˜¾ç¤ºå‡çº§é€‰é¡¹
        function showUpgradeOptions() {
            game.isPaused = true;
            const upgradeScreen = document.getElementById('upgradeScreen');
            const optionsContainer = document.getElementById('upgradeOptions');
            
            // æ¸…ç©ºä¹‹å‰çš„é€‰é¡¹
            optionsContainer.innerHTML = '';
            
            // éšæœºé€‰æ‹©3ä¸ªä¸åŒçš„å‡çº§
            const availableUpgrades = [...possibleUpgrades];
            const selectedUpgrades = [];
            
            for (let i = 0; i < 3 && availableUpgrades.length > 0; i++) {
                const index = Math.floor(Math.random() * availableUpgrades.length);
                selectedUpgrades.push(availableUpgrades[index]);
                availableUpgrades.splice(index, 1);
            }
            
            // åˆ›å»ºå‡çº§é€‰é¡¹UI
            selectedUpgrades.forEach(upgrade => {
                const option = document.createElement('div');
                option.className = 'upgrade-option';
                option.innerHTML = `
                    <div class="upgrade-title">${upgrade.title}</div>
                    <div class="upgrade-desc">${upgrade.description}</div>
                `;
                option.onclick = () => {
                    upgrade.apply();
                    upgradeScreen.style.display = 'none';
                    game.isPaused = false;
                    game.wave++;
                    spawnWave();
                };
                optionsContainer.appendChild(option);
            });
            
            upgradeScreen.style.display = 'block';
        }
        
        // ç”Ÿæˆæ•Œäººæ³¢æ¬¡
        function spawnWave() {
            const waveSize = 3 + game.wave * 2;
            const types = Object.keys(enemyTypes);
            
            for (let i = 0; i < waveSize; i++) {
                const angle = (Math.PI * 2 * i) / waveSize;
                const distance = Math.max(canvas.width, canvas.height) * 0.6;
                const x = game.player.x + Math.cos(angle) * distance;
                const y = game.player.y + Math.sin(angle) * distance;
                
                // æ ¹æ®æ³¢æ¬¡é€‰æ‹©æ•Œäººç±»å‹
                let type;
                if (game.wave < 3) {
                    type = 'imp';
                } else if (game.wave < 5) {
                    type = Math.random() < 0.7 ? 'imp' : 'brute';
                } else {
                    type = types[Math.floor(Math.random() * types.length)];
                }
                
                // é›†ç¾¤ç”Ÿæˆ
                if (type === 'swarm') {
                    for (let j = 0; j < 5; j++) {
                        const offsetX = (Math.random() - 0.5) * 50;
                        const offsetY = (Math.random() - 0.5) * 50;
                        game.enemies.push(new Enemy(type, x + offsetX, y + offsetY));
                    }
                } else {
                    game.enemies.push(new Enemy(type, x, y));
                }
            }
        }
        
        // è¾“å…¥å¤„ç†
        let touchStartPos = null;
        
        function handleStart(e) {
            if (game.isGameOver || game.isPaused || !game.hasStarted) return;
            
            const pos = getInputPosition(e);
            touchStartPos = pos;
            game.isDrawing = true;
            game.currentGlyph = [pos];
        }
        
        function handleMove(e) {
            if (!game.isDrawing || game.isGameOver || game.isPaused) return;
            
            const pos = getInputPosition(e);
            game.currentGlyph.push(pos);
        }
        
        function handleEnd(e) {
            if (!game.isDrawing || game.isGameOver || game.isPaused) return;
            
            game.isDrawing = false;
            
            if (game.currentGlyph.length > 5) {
                const glyphType = recognizeGlyph(game.currentGlyph);
                if (glyphType) {
                    castSpell(glyphType, game.currentGlyph[game.currentGlyph.length - 1]);
                }
            }
            
            game.currentGlyph = [];
        }
        
        function getInputPosition(e) {
            const rect = canvas.getBoundingClientRect();
            if (e.touches) {
                return {
                    x: e.touches[0].clientX - rect.left,
                    y: e.touches[0].clientY - rect.top
                };
            } else {
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }
        }
        
        // äº‹ä»¶ç›‘å¬
        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('touchstart', handleStart);
        canvas.addEventListener('touchmove', handleMove);
        canvas.addEventListener('touchend', handleEnd);
        
        // æ¸¸æˆå¾ªç¯
        let lastTime = 0;
        let waveTimer = 0;
        
        function gameLoop(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            if (!game.isGameOver && !game.isPaused && game.hasStarted) {
                update(deltaTime);
            }
            
            if (game.hasStarted) {
                render();
                updateSkillIcons(); // æ›´æ–°æŠ€èƒ½å›¾æ ‡çŠ¶æ€
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        function update(deltaTime) {
            // æ›´æ–°æ³•åŠ›å€¼
            game.mana = Math.min(game.mana + game.manaRegen, game.maxMana);
            
            // æ›´æ–°æ•Œäºº
            game.enemies.forEach(enemy => enemy.update());
            
            // æ›´æ–°æŠ•å°„ç‰©
            game.projectiles = game.projectiles.filter(projectile => projectile.update());
            
            // æ›´æ–°æ—‹æ¶¡
            game.vortexes = game.vortexes.filter(vortex => vortex.update(deltaTime));
            
            // æ›´æ–°ç‰¹æ•ˆ
            game.effects = game.effects.filter(effect => {
                if (effect instanceof Particle) {
                    return effect.update(deltaTime);
                } else if (effect.age !== undefined) {
                    effect.age += deltaTime;
                    effect.y -= 0.5;
                    return effect.age < effect.lifetime;
                }
                return true;
            });
            
            // æ£€æŸ¥æ³¢æ¬¡
            if (game.enemies.length === 0 && !game.isPaused) {
                waveTimer += deltaTime;
                if (waveTimer > 1000) {
                    showUpgradeOptions();
                    waveTimer = 0;
                }
            }
            
            // æ›´æ–°UI
            document.getElementById('score').textContent = game.score;
            document.getElementById('wave').textContent = game.wave;
            document.getElementById('manaFill').style.width = (game.mana / game.maxMana * 100) + '%';
            
            // æ£€æŸ¥æ¸¸æˆç»“æŸ
            if (game.isGameOver) {
                document.getElementById('finalScore').textContent = game.score;
                document.getElementById('finalWave').textContent = game.wave;
                document.getElementById('gameOver').style.display = 'block';
            }
        }
        
        function render() {
            // æ¸…ç©ºç”»å¸ƒ
            ctx.fillStyle = 'rgba(10, 10, 10, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶ç½‘æ ¼èƒŒæ™¯
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            const gridSize = 50;
            for (let x = 0; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // ç»˜åˆ¶ç©å®¶
            ctx.strokeStyle = '#4a90e2';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(game.player.x, game.player.y, game.player.radius, 0, Math.PI * 2);
            ctx.stroke();
            
            // ç»˜åˆ¶æŠ¤ç›¾
            if (game.player.shield > 0) {
                ctx.strokeStyle = glyphTemplates.circle.color;
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.5 + Math.sin(Date.now() * 0.005) * 0.2;
                for (let i = 0; i < game.player.shield; i++) {
                    ctx.beginPath();
                    ctx.arc(game.player.x, game.player.y, game.player.radius + 10 + i * 5, 0, Math.PI * 2);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;
            }
            
            // ç»˜åˆ¶å½“å‰ç¬¦æ–‡è½¨è¿¹
            if (game.currentGlyph.length > 1) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(game.currentGlyph[0].x, game.currentGlyph[0].y);
                for (let i = 1; i < game.currentGlyph.length; i++) {
                    ctx.lineTo(game.currentGlyph[i].x, game.currentGlyph[i].y);
                }
                ctx.stroke();
            }
            
            // ç»˜åˆ¶æ—‹æ¶¡
            game.vortexes.forEach(vortex => vortex.draw());
            
            // ç»˜åˆ¶æ•Œäºº
            game.enemies.forEach(enemy => enemy.draw());
            
            // ç»˜åˆ¶æŠ•å°„ç‰©
            game.projectiles.forEach(projectile => projectile.draw());
            
            // ç»˜åˆ¶ç‰¹æ•ˆ
            game.effects.forEach(effect => {
                if (effect instanceof Particle) {
                    effect.draw();
                } else if (effect.text) {
                    // ç»˜åˆ¶æ–‡å­—
                    ctx.fillStyle = effect.color;
                    ctx.font = 'bold 24px Arial';
                    ctx.textAlign = 'center';
                    ctx.globalAlpha = 1 - (effect.age / effect.lifetime);
                    ctx.fillText(effect.text, effect.x, effect.y);
                    ctx.globalAlpha = 1;
                }
            });
        }
        
        // UIåŠŸèƒ½
        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            document.getElementById('helpButton').style.display = 'block';
            document.getElementById('skillBar').style.display = 'flex'; // æ˜¾ç¤ºæŠ€èƒ½æ 
            game.hasStarted = true;
            game.player.x = canvas.width / 2;
            game.player.y = canvas.height / 2;
            spawnWave();
        }
        
        function showHelp() {
            document.getElementById('helpScreen').style.display = 'block';
            if (game.hasStarted) {
                game.isPaused = true;
            }
        }
        
        function hideHelp() {
            document.getElementById('helpScreen').style.display = 'none';
            if (game.hasStarted) {
                game.isPaused = false;
            }
        }
        
        // ç”Ÿæˆç¬¦æ–‡æŒ‡å—
        function generateGlyphGuide() {
            const guide = document.getElementById('glyphGuide');
            const glyphs = [
                { type: 'line', name: 'ç›´çº¿', desc: 'ç«çƒæœ¯ - æ¶ˆè€—10æ³•åŠ›' },
                { type: 'circle', name: 'åœ†åœˆ', desc: 'é­”æ³•æŠ¤ç›¾ - æ¶ˆè€—30æ³•åŠ›' },
                { type: 'triangle', name: 'ä¸‰è§’å½¢', desc: 'è¿½è¸ªé£å¼¹ - æ¶ˆè€—20æ³•åŠ›' },
                { type: 'z', name: 'Zå­—å½¢', desc: 'è¿é”é—ªç”µ - æ¶ˆè€—40æ³•åŠ›' },
                { type: 'spiral', name: 'èºæ—‹', desc: 'å¼•åŠ›æ—‹æ¶¡ - æ¶ˆè€—50æ³•åŠ›' }
            ];
            
            glyphs.forEach(glyph => {
                const item = document.createElement('div');
                item.className = 'glyph-item';
                
                const canvas = document.createElement('canvas');
                canvas.width = 200;
                canvas.height = 80;
                const ctx = canvas.getContext('2d');
                
                // ç»˜åˆ¶ç¤ºä¾‹ç¬¦æ–‡
                ctx.strokeStyle = glyphTemplates[glyph.type].color;
                ctx.lineWidth = 3;
                ctx.beginPath();
                
                switch(glyph.type) {
                    case 'line':
                        ctx.moveTo(30, 40);
                        ctx.lineTo(170, 40);
                        break;
                    case 'circle':
                        ctx.arc(100, 40, 30, 0, Math.PI * 2);
                        break;
                    case 'triangle':
                        ctx.moveTo(100, 20);
                        ctx.lineTo(50, 60);
                        ctx.lineTo(150, 60);
                        ctx.closePath();
                        break;
                    case 'z':
                        ctx.moveTo(50, 20);
                        ctx.lineTo(150, 20);
                        ctx.lineTo(50, 60);
                        ctx.lineTo(150, 60);
                        break;
                    case 'spiral':
                        for (let angle = 0; angle < Math.PI * 4; angle += 0.2) {
                            const radius = 10 + angle * 3;
                            const x = 100 + Math.cos(angle) * radius;
                            const y = 40 + Math.sin(angle) * radius;
                            if (angle === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        break;
                }
                ctx.stroke();
                
                item.innerHTML = `
                    <div class="glyph-name">${glyph.name}</div>
                    <div class="glyph-desc">${glyph.desc}</div>
                `;
                item.insertBefore(canvas, item.firstChild);
                guide.appendChild(item);
            });
        }
        
        // åˆå§‹åŒ–
        generateGlyphGuide();
        gameLoop(0);
    </script>
</body>
</html>
