<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D 防守游戏</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #222;
        }
        #gameCanvas {
            display: block;
            background: #1a1a1a;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 5px;
            font-size: 14px;
            border: 2px solid #444;
            z-index: 10;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            display: none;
            border: 2px solid #f00;
            z-index: 1000;
        }
        #gameOver button {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
        }
        #gameOver button:hover {
            background: #45a049;
        }
        .stat-line {
            margin: 5px 0;
        }
        .stat-value {
            color: #0f0;
            font-weight: bold;
        }
        #upgradeMenu {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 5px;
            display: none;
            border: 2px solid #0f0;
            z-index: 100;
        }
        .upgrade-btn {
            margin: 5px;
            padding: 8px 15px;
            cursor: pointer;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 3px;
            font-size: 12px;
        }
        .upgrade-btn:hover {
            background: #45a049;
        }
        .upgrade-btn:disabled {
            background: #666;
            cursor: not-allowed;
        }
        #waveNotice {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff0;
            font-size: 48px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            display: none;
            pointer-events: none;
            z-index: 50;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 600; /* 确保控制按钮在暂停遮罩之上 */
        }
        .control-btn {
            padding: 10px 20px;
            background: #333;
            color: white;
            border: 2px solid #666;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        .control-btn:hover {
            background: #444;
            border-color: #888;
        }
        .control-btn.active {
            background: #4CAF50;
            border-color: #45a049;
        }
        #difficultyMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px;
            border-radius: 10px;
            border: 2px solid #0f0;
            text-align: center;
            z-index: 1000;
        }
        #difficultyMenu h2 {
            color: white;
            margin-bottom: 20px;
        }
        .difficulty-btn {
            display: block;
            width: 200px;
            margin: 10px auto;
            padding: 15px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        .difficulty-btn:hover {
            background: #45a049;
        }
        .difficulty-desc {
            color: #fcfafa;
            font-size: 13px;
            margin-top: 5px;
        }
        #pauseOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 500; /* 在控制按钮之下 */
        }
        #pauseOverlay h2 {
            color: white;
            font-size: 48px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        .ammo-bar {
            margin-top: 10px;
            background: #333;
            height: 20px;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #666;
        }
        .ammo-fill {
            height: 100%;
            background: linear-gradient(to right, #00ff00, #00aa00);
            transition: width 0.3s;
        }
        #skillInfo {
            position: absolute;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 5px;
            display: none;
            border: 2px solid #ff0;
            z-index: 100;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="difficultyMenu" style="height: 80vh; overflow: hidden; display: flex; flex-direction: column;">
        <!-- 顶部标题区域 -->
        <div style="text-align: center; padding: 20px 0; background: rgba(0,0,0,0.9); color: white;">
            <h1 style="color: #ffff00; margin: 0; font-size: 28px;">🎮 无限防守</h1>
            <p style="margin: 10px 0 0 0; font-size: 18px;"><strong>目标：</strong>在无尽的怪物波次中生存下去！</p>
        </div>

        <!-- 主要内容区域 -->
        <div style="display: flex; flex: 1; overflow: hidden;">
            <!-- 左侧：游戏说明 -->
            <div style="flex: 1; background: rgba(0,0,0,0.8); padding: 15px; color: white; text-align: left; overflow: hidden; border-right: 2px solid #333;">
                <!-- 双列布局容器 -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; height: 100%;">
                    <!-- 左列 -->
                    <div>
                        <h3 style="color: #00ff00; font-size: 16px; margin: 0 0 8px 0;">⚔️ 战斗系统</h3>
                        <ul style="font-size: 14px; margin: 0 0 15px 0; padding-left: 15px;">
                            <li>自动攻击范围内最近的敌人</li>
                            <li>弹药有限，及时换弹（R键）</li>
                            <li>每波结束后升级属性</li>
                        </ul>

                        <h3 style="color: #ff00ff; font-size: 16px; margin: 0 0 8px 0;">🎯 操作说明</h3>
                        <ul style="font-size: 14px; margin: 0 0 15px 0; padding-left: 15px;">
                            <li><strong>P键</strong> - 暂停/继续</li>
                            <li><strong>U键</strong> - 升级面板</li>
                            <li><strong>R键</strong> - 手动换弹</li>
                            <li><strong>倍速按钮</strong> - 1x/2x/3x速度</li>
                        </ul>

                        <h3 style="color: #ffff00; font-size: 16px; margin: 0 0 8px 0;">� 升级限制</h3>
                        <ul style="font-size: 14px; margin: 0; padding-left: 15px;">
                            <li><strong>攻速</strong> - 最多15级</li>
                            <li><strong>子弹数量</strong> - 最多2级</li>
                            <li><strong>射程</strong> - 最多10级</li>
                            <li><strong>换弹速度</strong> - 最多8级</li>
                        </ul>
                    </div>

                    <!-- 右列 -->
                    <div>
                        <h3 style="color: #ff8800; font-size: 16px; margin: 0 0 8px 0;">👹 敌人类型</h3>
                        <ul style="font-size: 14px; margin: 0 0 15px 0; padding-left: 15px;">
                            <li><strong>普通怪</strong> - 基础敌人</li>
                            <li><strong>快速怪</strong> - 速度快血量少</li>
                            <li><strong>坦克怪</strong> - 血厚移动慢</li>
                            <li><strong>精英怪</strong> - 每5波，有特技</li>
                            <li><strong>Boss</strong> - 每10波，多种技能</li>
                        </ul>

                        <h3 style="color: #00ffff; font-size: 16px; margin: 0 0 8px 0;">⚡ Boss特技</h3>
                        <ul style="font-size: 14px; margin: 0; padding-left: 15px;">
                            <li><strong>冲刺</strong> - 快速冲击</li>
                            <li><strong>召唤</strong> - 召唤小怪</li>
                            <li><strong>狂暴</strong> - 速度伤害增加</li>
                            <li><strong>激光</strong> - 高伤害射线</li>
                            <li><strong>传送</strong> - 瞬移攻击</li>
                            <li><strong>护盾</strong> - 吸收伤害</li>
                            <li><strong>地震</strong> - 范围攻击</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- 右侧：难度选择 -->
            <div style="flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; background: rgba(0,0,0,0.7); padding: 30px;">
                <h2 style="color: white; margin-bottom: 30px; text-align: center; font-size: 24px;">选择难度</h2>

                <button class="difficulty-btn" onclick="game.selectDifficulty('kindergarten')" style="margin: 8px 0; width: 280px;">
                    幼儿园
                    <div class="difficulty-desc">敌人很弱，资源丰富</div>
                </button>
                <button class="difficulty-btn" onclick="game.selectDifficulty('elementary')" style="margin: 8px 0; width: 280px;">
                    小学生
                    <div class="difficulty-desc">适合新手练习</div>
                </button>
                <button class="difficulty-btn" onclick="game.selectDifficulty('middle')" style="margin: 8px 0; width: 280px;">
                    初中生
                    <div class="difficulty-desc">标准难度</div>
                </button>
                <button class="difficulty-btn" onclick="game.selectDifficulty('high')" style="margin: 8px 0; width: 280px;">
                    高中生
                    <div class="difficulty-desc">需要一定技巧</div>
                </button>
                <button class="difficulty-btn" onclick="game.selectDifficulty('university')" style="margin: 8px 0; width: 280px;">
                    大学生
                    <div class="difficulty-desc">极限挑战</div>
                </button>
            </div>
        </div>
    </div>
    
    <div id="pauseOverlay">
        <h2>游戏暂停</h2>
    </div>
    
    <div id="ui">
        <div class="stat-line">难度: <span class="stat-value" id="difficulty">-</span></div>
        <div class="stat-line">波数: <span class="stat-value" id="wave">1</span></div>
        <div class="stat-line">击杀数: <span class="stat-value" id="kills">0</span></div>
        <div class="stat-line">金币: <span class="stat-value" id="gold">50</span></div>
        <div class="stat-line">经验: <span class="stat-value" id="exp">0</span> / <span id="expNeeded">50</span></div>
        <div class="stat-line">等级: <span class="stat-value" id="level">1</span></div>
        <hr>
        <div class="stat-line">生命值: <span class="stat-value" id="hp">100</span> / <span id="maxHp">100</span></div>
        <div class="stat-line">攻击力: <span class="stat-value" id="damage">25</span></div>
        <div class="stat-line">攻击速度: <span class="stat-value" id="attackSpeed">2.0</span>/秒</div>
        <div class="stat-line">攻击范围: <span class="stat-value" id="range">150</span></div>
        <div class="stat-line">生命回复: <span class="stat-value" id="regen">1</span>/秒</div>
        <div class="stat-line">子弹数量: <span class="stat-value" id="bulletCount">1</span></div>
        <div class="stat-line">弹匣容量: <span class="stat-value" id="ammo">30</span> / <span id="maxAmmo">30</span></div>
        <div class="ammo-bar">
            <div class="ammo-fill" id="ammoBar" style="width: 100%"></div>
        </div>
    </div>
    
    <div id="controls">
        <button class="control-btn" id="pauseBtn" onclick="game.togglePause()">暂停 (P)</button>
        <button class="control-btn" id="upgradeBtn" onclick="game.toggleUpgradeMenu()">升级面板 (U)</button>
        <button class="control-btn" id="speedBtn" onclick="game.toggleSpeed()">倍速: 1x</button>
    </div>
    
    <div id="upgradeMenu">
        <h3 style="color: white; margin: 0 0 10px 0;">升级面板</h3>
        <button class="upgrade-btn" id="upgradeDamage">攻击力 +10 (30金币)</button>
        <button class="upgrade-btn" id="upgradeSpeed">攻速 +0.5 (25金币)</button>
        <button class="upgrade-btn" id="upgradeHp">生命值 +50 (20金币)</button>
        <button class="upgrade-btn" id="upgradeRange">射程 +20 (35金币)</button>
        <button class="upgrade-btn" id="upgradeRegen">生命回复 +1 (40金币)</button>
        <button class="upgrade-btn" id="upgradeBullets">子弹数量 +1 (100金币)</button>
        <button class="upgrade-btn" id="upgradeAmmo">弹匣容量 +10 (50金币)</button>
        <button class="upgrade-btn" id="upgradeReload">换弹速度 +20% (60金币)</button>
    </div>
    
    <div id="skillInfo"></div>
    
    <div id="waveNotice"></div>
    
    <div id="gameOver">
        <h2>游戏结束！</h2>
        <p>难度: <span id="finalDifficulty">-</span></p>
        <p>你坚持到了第 <span id="finalWave">1</span> 波</p>
        <p>总击杀数: <span id="finalKills">0</span></p>
        <p>最高等级: <span id="finalLevel">1</span></p>
        <button onclick="location.reload()">重新开始</button>
    </div>

    <script>
        class DefenseGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                
                // 难度设置
                this.difficulty = null;
                this.difficultySettings = {
                    kindergarten: {
                        name: '幼儿园',
                        enemyHpMultiplier: 0.5,
                        enemyDamageMultiplier: 0.5,
                        enemySpeedMultiplier: 0.7,
                        goldMultiplier: 2,
                        expMultiplier: 1.5,
                        startGold: 100
                    },
                    elementary: {
                        name: '小学生',
                        enemyHpMultiplier: 0.75,
                        enemyDamageMultiplier: 0.75,
                        enemySpeedMultiplier: 0.85,
                        goldMultiplier: 1.5,
                        expMultiplier: 1.25,
                        startGold: 75
                    },
                    middle: {
                        name: '初中生',
                        enemyHpMultiplier: 1,
                        enemyDamageMultiplier: 1,
                        enemySpeedMultiplier: 1,
                        goldMultiplier: 1,
                        expMultiplier: 1,
                        startGold: 50
                    },
                    high: {
                        name: '高中生',
                        enemyHpMultiplier: 1.5,
                        enemyDamageMultiplier: 1.5,
                        enemySpeedMultiplier: 1.2,
                        goldMultiplier: 0.8,
                        expMultiplier: 0.9,
                        startGold: 30
                    },
                    university: {
                        name: '大学生',
                        enemyHpMultiplier: 2,
                        enemyDamageMultiplier: 2,
                        enemySpeedMultiplier: 1.5,
                        goldMultiplier: 0.6,
                        expMultiplier: 0.8,
                        startGold: 20
                    }
                };
                
                this.player = {
                    x: this.canvas.width / 2,
                    y: this.canvas.height / 2,
                    radius: 20,
                    hp: 100,
                    maxHp: 100,
                    damage: 25,
                    attackSpeed: 2.0,
                    range: 150,
                    regen: 1,
                    bulletCount: 1,
                    ammo: 30,
                    maxAmmo: 30,
                    reloadSpeed: 2000, // 2秒换弹
                    isReloading: false,
                    reloadStartTime: 0,
                    color: '#00ff00',
                    lastAttackTime: 0,
                    lastRegenTime: 0
                };
                
                this.enemies = [];
                this.projectiles = [];
                this.particles = [];
                this.floatingTexts = [];
                
                this.wave = 1;
                this.enemiesInWave = 0;
                this.enemiesSpawned = 0;
                this.kills = 0;
                this.gold = 50;
                this.exp = 0;
                this.level = 1;
                this.expNeeded = 50;
                
                this.isPaused = false;
                this.isGameStarted = false;
                this.isWaveComplete = false;
                this.lastTime = 0;
                this.spawnTimer = 0;
                this.gameSpeed = 1; // 游戏倍速
                this.speedOptions = [1, 2, 3]; // 可选倍速
                this.currentSpeedIndex = 0;
                
                this.upgradeCosts = {
                    damage: 30,
                    attackSpeed: 25,
                    maxHp: 20,
                    range: 35,
                    regen: 40,
                    bulletCount: 100,
                    maxAmmo: 50,
                    reloadSpeed: 60
                };

                // 升级等级跟踪
                this.upgradeLevels = {
                    damage: 0,
                    attackSpeed: 0,
                    maxHp: 0,
                    range: 0,
                    regen: 0,
                    bulletCount: 0,
                    maxAmmo: 0,
                    reloadSpeed: 0
                };

                // 升级上限设置
                this.upgradeMaxLevels = {
                    damage: 999, // 攻击力可以无限升级
                    attackSpeed: 15, // 攻速最多升级15次
                    maxHp: 999, // 生命值可以无限升级
                    range: 10, // 射程最多升级10次
                    regen: 999, // 生命回复可以无限升级
                    bulletCount: 2, // 子弹数量最多升级2次
                    maxAmmo: 999, // 弹匣容量可以无限升级
                    reloadSpeed: 8 // 换弹速度最多升级8次
                };
                
                this.init();
            }
            
            init() {
                // 绑定升级按钮
                document.getElementById('upgradeDamage').onclick = () => this.upgradePlayer('damage');
                document.getElementById('upgradeSpeed').onclick = () => this.upgradePlayer('attackSpeed');
                document.getElementById('upgradeHp').onclick = () => this.upgradePlayer('maxHp');
                document.getElementById('upgradeRange').onclick = () => this.upgradePlayer('range');
                document.getElementById('upgradeRegen').onclick = () => this.upgradePlayer('regen');
                document.getElementById('upgradeBullets').onclick = () => this.upgradePlayer('bulletCount');
                document.getElementById('upgradeAmmo').onclick = () => this.upgradePlayer('maxAmmo');
                document.getElementById('upgradeReload').onclick = () => this.upgradePlayer('reloadSpeed');
                
                // 键盘事件
                window.addEventListener('keydown', (e) => {
                    if (e.key === 'p' || e.key === 'P') {
                        this.togglePause();
                    } else if (e.key === 'u' || e.key === 'U') {
                        this.toggleUpgradeMenu();
                    } else if (e.key === 'r' || e.key === 'R') {
                        this.reload();
                    }
                });
                
                // 监听窗口大小变化
                window.addEventListener('resize', () => {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                    this.player.x = this.canvas.width / 2;
                    this.player.y = this.canvas.height / 2;
                });
                
                // 开始游戏循环
                this.gameLoop();
            }
            
            selectDifficulty(difficulty) {
                this.difficulty = difficulty;
                const settings = this.difficultySettings[difficulty];
                this.gold = settings.startGold;
                this.isGameStarted = true;
                
                document.getElementById('difficultyMenu').style.display = 'none';
                document.getElementById('difficulty').textContent = settings.name;
                
                this.startWave();
                this.updateUI();
            }
            
            togglePause() {
                if (!this.isGameStarted) return;

                this.isPaused = !this.isPaused;
                const pauseOverlay = document.getElementById('pauseOverlay');
                const pauseBtn = document.getElementById('pauseBtn');

                if (this.isPaused) {
                    pauseOverlay.style.display = 'flex';
                    pauseBtn.textContent = '继续 (P)';
                    pauseBtn.classList.add('active');
                } else {
                    pauseOverlay.style.display = 'none';
                    pauseBtn.textContent = '暂停 (P)';
                    pauseBtn.classList.remove('active');
                }
            }

            toggleSpeed() {
                if (!this.isGameStarted) return;

                this.currentSpeedIndex = (this.currentSpeedIndex + 1) % this.speedOptions.length;
                this.gameSpeed = this.speedOptions[this.currentSpeedIndex];
                document.getElementById('speedBtn').textContent = `倍速: ${this.gameSpeed}x`;
            }
            
            toggleUpgradeMenu() {
                if (!this.isGameStarted) return;
                
                const menu = document.getElementById('upgradeMenu');
                const btn = document.getElementById('upgradeBtn');
                
                if (menu.style.display === 'block') {
                    menu.style.display = 'none';
                    btn.classList.remove('active');
                } else {
                    menu.style.display = 'block';
                    btn.classList.add('active');
                    this.updateUpgradeButtons();
                }
            }
            
            reload() {
                if (this.player.ammo === this.player.maxAmmo || this.player.isReloading) return;
                
                this.player.isReloading = true;
                this.player.reloadStartTime = Date.now();
                
                this.showSkillInfo('换弹中...');
                
                setTimeout(() => {
                    this.player.ammo = this.player.maxAmmo;
                    this.player.isReloading = false;
                    this.hideSkillInfo();
                }, this.player.reloadSpeed);
            }
            
            showSkillInfo(text) {
                const info = document.getElementById('skillInfo');
                info.textContent = text;
                info.style.display = 'block';
            }
            
            hideSkillInfo() {
                document.getElementById('skillInfo').style.display = 'none';
            }
            
            startWave() {
                this.isWaveComplete = false;
                const config = this.getWaveConfig(this.wave);
                this.enemiesInWave = config.enemyCount;
                this.enemiesSpawned = 0;
                this.spawnTimer = 0;
                
                // 显示波数提示
                this.showWaveNotice();
                
                // 波数奖励（从第2波开始）
                if (this.wave > 1) {
                    const settings = this.difficultySettings[this.difficulty];
                    const bonus = Math.floor((this.wave - 1) * 15 * settings.goldMultiplier);
                    this.gold += bonus;
                    this.createFloatingText(this.player.x, this.player.y - 50, `+${bonus}金币`, '#ffff00');
                }
            }
            
            showWaveNotice() {
                const notice = document.getElementById('waveNotice');
                notice.textContent = `第 ${this.wave} 波`;
                notice.style.display = 'block';
                
                if (this.wave % 10 === 0) {
                    notice.style.color = '#ff0000';
                    notice.textContent += ' - BOSS来袭！';
                } else if (this.wave % 5 === 0) {
                    notice.style.color = '#ff00ff';
                    notice.textContent += ' - 精英怪出现！';
                }
                
                setTimeout(() => {
                    notice.style.display = 'none';
                }, 2000);
            }
            
            getWaveConfig(wave) {
                // 指数级难度递增，前10波相对简单，之后快速增长
                const baseCount = wave <= 10 ? 3 + Math.floor(wave * 1.5) : 8 + Math.floor(wave * 3.0);
                const exponentialMultiplier = wave > 10 ? Math.pow(1.15, wave - 10) : 1;

                return {
                    enemyCount: Math.floor(baseCount * exponentialMultiplier * 1.5), // 提高50%怪物数量
                    spawnDelay: Math.max(200, 1500 - wave * 50), // 更快的生成速度
                    enemyHpMultiplier: 1 + (wave - 1) * 0.2 * exponentialMultiplier, // 指数级血量增长
                    enemyDamageMultiplier: 1 + (wave - 1) * 0.15 * exponentialMultiplier, // 指数级伤害增长
                    enemySpeedMultiplier: 1 + Math.min((wave - 1) * 0.08, 1.5), // 更高的速度上限
                    specialChance: Math.min(0.5, wave * 0.05), // 更高的特殊怪物概率
                    goldMultiplier: Math.max(0.3, 1 - wave * 0.02), // 金币获取递减
                    expMultiplier: Math.max(0.4, 1 - wave * 0.015) // 经验获取递减
                };
            }
            
            spawnEnemy() {
                const config = this.getWaveConfig(this.wave);
                let type = 'normal';
                
                // 决定敌人类型
                if (this.wave % 10 === 0 && this.enemiesSpawned === this.enemiesInWave - 1) {
                    type = 'boss';
                } else if (this.wave % 5 === 0 && this.enemiesSpawned >= this.enemiesInWave - 2) {
                    type = 'elite';
                } else if (Math.random() < config.specialChance) {
                    type = Math.random() < 0.5 ? 'fast' : 'tank';
                }
                
                const enemyStats = this.getEnemyStats(type, config);
                
                // 随机生成位置（在屏幕边缘）
                const side = Math.floor(Math.random() * 4);
                let x, y;
                
                switch(side) {
                    case 0: // 上
                        x = Math.random() * this.canvas.width;
                        y = -20;
                        break;
                    case 1: // 右
                        x = this.canvas.width + 20;
                        y = Math.random() * this.canvas.height;
                        break;
                    case 2: // 下
                        x = Math.random() * this.canvas.width;
                        y = this.canvas.height + 20;
                        break;
                    case 3: // 左
                        x = -20;
                        y = Math.random() * this.canvas.height;
                        break;
                }
                
                const enemy = {
                    x: x,
                    y: y,
                    ...enemyStats,
                    angle: 0
                };
                
                this.enemies.push(enemy);
                this.enemiesSpawned++;
            }
            
            getEnemyStats(type, config) {
                const difficultySettings = this.difficultySettings[this.difficulty];
                
                const baseStats = {
                    normal: {
                        radius: 15,
                        hp: 30,
                        maxHp: 30,
                        damage: 5,
                        speed: 1,
                        color: '#ff0000',
                        goldReward: 10,
                        expReward: 10
                    },
                    fast: {
                        radius: 10,
                        hp: 20,
                        maxHp: 20,
                        damage: 3,
                        speed: 2,
                        color: '#ffff00',
                        goldReward: 15,
                        expReward: 15
                    },
                    tank: {
                        radius: 20,
                        hp: 80,
                        maxHp: 80,
                        damage: 8,
                        speed: 0.5,
                        color: '#8b4513',
                        goldReward: 25,
                        expReward: 20
                    },
                    elite: {
                        radius: 25,
                        hp: 150,
                        maxHp: 150,
                        damage: 12,
                        speed: 0.8,
                        color: '#ff00ff',
                        goldReward: 50,
                        expReward: 40,
                        hasSpecialAbility: true,
                        specialAbilities: ['dash', 'split'],
                        lastSpecialTime: 0,
                        specialCooldown: 3000 // 3秒冷却
                    },
                    boss: {
                        radius: 35,
                        hp: 500,
                        maxHp: 500,
                        damage: 20,
                        speed: 0.4,
                        color: '#ff0000',
                        goldReward: 150,
                        expReward: 100,
                        hasSpecialAbility: true,
                        specialAbilities: ['dash', 'summon', 'rage', 'laser', 'teleport', 'shield', 'earthquake'],
                        lastSpecialTime: 0,
                        specialCooldown: 3000, // 3秒冷却
                        isRaging: false,
                        rageEndTime: 0,
                        hasShield: false,
                        shieldEndTime: 0,
                        shieldHp: 0,
                        lastTeleportTime: 0,
                        earthquakeCharging: false,
                        earthquakeStartTime: 0
                    }
                };
                
                const stats = { ...baseStats[type], type: type };
                
                // 应用波数加成
                stats.hp = Math.floor(stats.hp * config.enemyHpMultiplier * difficultySettings.enemyHpMultiplier);
                stats.maxHp = Math.floor(stats.maxHp * config.enemyHpMultiplier * difficultySettings.enemyHpMultiplier);
                stats.damage = Math.floor(stats.damage * config.enemyDamageMultiplier * difficultySettings.enemyDamageMultiplier);
                stats.speed = stats.speed * config.enemySpeedMultiplier * difficultySettings.enemySpeedMultiplier;
                // 应用波次递减的金币和经验奖励
                stats.goldReward = Math.floor(stats.goldReward * difficultySettings.goldMultiplier * config.goldMultiplier);
                stats.expReward = Math.floor(stats.expReward * difficultySettings.expMultiplier * config.expMultiplier);
                
                return stats;
            }
            
            createProjectile(target) {
                if (this.player.ammo <= 0 || this.player.isReloading) {
                    if (!this.player.isReloading) {
                        this.reload();
                    }
                    return;
                }
                
                const baseAngle = Math.atan2(target.y - this.player.y, target.x - this.player.x);
                
                // 根据子弹数量创建多个投射物
                for (let i = 0; i < this.player.bulletCount; i++) {
                    let angle = baseAngle;
                    
                    // 多子弹散射
                    if (this.player.bulletCount > 1) {
                        const spread = 0.2; // 散射角度
                        const offset = (i - (this.player.bulletCount - 1) / 2) * spread;
                        angle += offset;
                    }
                    
                    this.projectiles.push({
                        x: this.player.x,
                        y: this.player.y,
                        vx: Math.cos(angle) * 10,
                        vy: Math.sin(angle) * 10,
                        damage: this.player.damage,
                        radius: 5,
                        color: '#00ffff',
                        target: target,
                        piercing: this.player.level >= 10 ? 1 : 0
                    });
                }
                
                this.player.ammo--;
                
                // 自动换弹
                if (this.player.ammo <= 0) {
                    this.reload();
                }
            }
            
            createParticle(x, y, color, count = 5) {
                for (let i = 0; i < count; i++) {
                    const angle = (Math.PI * 2 / count) * i + Math.random() * 0.5;
                    const speed = 2 + Math.random() * 3;
                    
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        radius: 3,
                        color: color,
                        life: 1.0,
                        decay: 0.02
                    });
                }
            }
            
            createFloatingText(x, y, text, color) {
                this.floatingTexts.push({
                    x: x,
                    y: y,
                    text: text,
                    color: color,
                    vy: -2,
                    life: 1.0
                });
            }
            
            update(deltaTime) {
                if (this.isPaused || !this.isGameStarted) return;

                // 应用倍速
                deltaTime *= this.gameSpeed;
                
                // 生成敌人
                if (this.enemiesSpawned < this.enemiesInWave && !this.isWaveComplete) {
                    this.spawnTimer += deltaTime;
                    const config = this.getWaveConfig(this.wave);
                    if (this.spawnTimer >= config.spawnDelay) {
                        this.spawnEnemy();
                        this.spawnTimer = 0;
                    }
                }
                
                // 玩家自动攻击
                const currentTime = Date.now();
                const attackInterval = 1000 / this.player.attackSpeed;
                
                if (currentTime - this.player.lastAttackTime >= attackInterval && this.enemies.length > 0 && !this.player.isReloading) {
                    // 找最近的敌人
                    let closestEnemy = null;
                    let closestDist = this.player.range;
                    
                    for (const enemy of this.enemies) {
                        const dist = Math.hypot(enemy.x - this.player.x, enemy.y - this.player.y);
                        if (dist < closestDist) {
                            closestDist = dist;
                            closestEnemy = enemy;
                        }
                    }
                    
                    if (closestEnemy) {
                        this.createProjectile(closestEnemy);
                        this.player.lastAttackTime = currentTime;
                    }
                }
                
                // 玩家生命回复
                if (currentTime - this.player.lastRegenTime >= 1000) {
                    if (this.player.hp < this.player.maxHp) {
                        this.player.hp = Math.min(this.player.hp + this.player.regen, this.player.maxHp);
                        this.player.lastRegenTime = currentTime;
                    }
                }
                
                // 更新敌人
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];

                    // 处理特殊能力
                    if (enemy.hasSpecialAbility) {
                        this.updateEnemySpecialAbilities(enemy, currentTime);
                    }

                    // 移动向玩家
                    const dx = this.player.x - enemy.x;
                    const dy = this.player.y - enemy.y;
                    const dist = Math.hypot(dx, dy);

                    let moveSpeed = enemy.speed;

                    // Boss狂暴状态下速度翻倍
                    if (enemy.isRaging && currentTime < enemy.rageEndTime) {
                        moveSpeed *= 2;
                        enemy.color = '#ff4444'; // 狂暴时颜色变化
                    } else if (enemy.type === 'boss') {
                        enemy.color = '#ff0000'; // 恢复原色
                        enemy.isRaging = false;
                    }

                    if (dist > 0) {
                        enemy.x += (dx / dist) * moveSpeed;
                        enemy.y += (dy / dist) * moveSpeed;
                        enemy.angle = Math.atan2(dy, dx);
                    }

                    // 检查碰撞
                    if (dist < this.player.radius + enemy.radius) {
                        this.damagePlayer(enemy.damage);
                        this.createParticle(enemy.x, enemy.y, enemy.color);
                        this.enemies.splice(i, 1);
                    }
                }
                
                // 更新投射物
                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    const proj = this.projectiles[i];
                    
                    proj.x += proj.vx;
                    proj.y += proj.vy;
                    
                    // 检查边界
                    if (proj.x < 0 || proj.x > this.canvas.width || 
                        proj.y < 0 || proj.y > this.canvas.height) {
                        this.projectiles.splice(i, 1);
                        continue;
                    }
                    
                    // 检查碰撞
                    let hit = false;
                    for (let j = this.enemies.length - 1; j >= 0; j--) {
                        const enemy = this.enemies[j];
                        const dist = Math.hypot(enemy.x - proj.x, enemy.y - proj.y);
                        
                        if (dist < enemy.radius + proj.radius) {
                            this.damageEnemy(enemy, j, proj.damage);
                            hit = true;
                            
                            if (proj.piercing > 0) {
                                proj.piercing--;
                            } else {
                                this.projectiles.splice(i, 1);
                            }
                            break;
                        }
                    }
                }
                
                // 更新粒子
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vy += 0.2;
                    particle.life -= particle.decay;
                    
                    if (particle.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
                
                // 更新浮动文字
                for (let i = this.floatingTexts.length - 1; i >= 0; i--) {
                    const text = this.floatingTexts[i];
                    
                    text.y += text.vy;
                    text.life -= 0.02;
                    
                    if (text.life <= 0) {
                        this.floatingTexts.splice(i, 1);
                    }
                }
                
                // 检查波次完成
                if (this.enemies.length === 0 && this.enemiesSpawned >= this.enemiesInWave && !this.isWaveComplete) {
                    this.isWaveComplete = true;
                    this.showUpgradeMenu();
                    
                    setTimeout(() => {
                        this.hideUpgradeMenu();
                        this.wave++;
                        this.startWave();
                    }, 3000);
                }
                
                this.updateUI();
            }
            
            updateEnemySpecialAbilities(enemy, currentTime) {
                if (currentTime - enemy.lastSpecialTime < enemy.specialCooldown) {
                    return;
                }

                const playerDist = Math.hypot(enemy.x - this.player.x, enemy.y - this.player.y);

                // 随机选择一个特技
                const ability = enemy.specialAbilities[Math.floor(Math.random() * enemy.specialAbilities.length)];

                switch(ability) {
                    case 'dash':
                        if (playerDist < 200) {
                            this.enemyDash(enemy);
                            enemy.lastSpecialTime = currentTime;
                        }
                        break;
                    case 'split':
                        if (enemy.hp < enemy.maxHp * 0.5) { // 血量低于50%时分裂
                            this.enemySplit(enemy);
                            enemy.lastSpecialTime = currentTime;
                        }
                        break;
                    case 'summon':
                        if (playerDist < 300) {
                            this.enemySummon(enemy);
                            enemy.lastSpecialTime = currentTime;
                        }
                        break;
                    case 'rage':
                        if (enemy.hp < enemy.maxHp * 0.3) { // 血量低于30%时狂暴
                            this.enemyRage(enemy, currentTime);
                            enemy.lastSpecialTime = currentTime;
                        }
                        break;
                    case 'laser':
                        if (playerDist < 400) {
                            this.enemyLaser(enemy);
                            enemy.lastSpecialTime = currentTime;
                        }
                        break;
                    case 'teleport':
                        if (playerDist < 100 && currentTime - enemy.lastTeleportTime > 8000) {
                            this.enemyTeleport(enemy, currentTime);
                            enemy.lastSpecialTime = currentTime;
                        }
                        break;
                    case 'shield':
                        if (enemy.hp < enemy.maxHp * 0.6 && !enemy.hasShield) {
                            this.enemyShield(enemy, currentTime);
                            enemy.lastSpecialTime = currentTime;
                        }
                        break;
                    case 'earthquake':
                        if (playerDist < 250 && !enemy.earthquakeCharging) {
                            this.enemyEarthquake(enemy, currentTime);
                            enemy.lastSpecialTime = currentTime;
                        }
                        break;
                }
            }

            enemyDash(enemy) {
                // 冲刺向玩家
                const dx = this.player.x - enemy.x;
                const dy = this.player.y - enemy.y;
                const dist = Math.hypot(dx, dy);

                if (dist > 0) {
                    const dashDistance = 100;
                    enemy.x += (dx / dist) * dashDistance;
                    enemy.y += (dy / dist) * dashDistance;

                    // 冲刺特效
                    this.createParticle(enemy.x, enemy.y, enemy.color, 15);
                    this.createFloatingText(enemy.x, enemy.y - 30, '冲刺!', '#ff0000');
                }
            }

            enemySplit(enemy) {
                // 分裂成两个小怪
                const splitEnemy1 = {
                    x: enemy.x + 30,
                    y: enemy.y,
                    radius: enemy.radius * 0.7,
                    hp: enemy.hp * 0.6,
                    maxHp: enemy.maxHp * 0.6,
                    damage: enemy.damage * 0.8,
                    speed: enemy.speed * 1.3,
                    color: enemy.color,
                    goldReward: Math.floor(enemy.goldReward * 0.4),
                    expReward: Math.floor(enemy.expReward * 0.4),
                    type: 'split',
                    angle: 0
                };

                const splitEnemy2 = {
                    x: enemy.x - 30,
                    y: enemy.y,
                    radius: enemy.radius * 0.7,
                    hp: enemy.hp * 0.6,
                    maxHp: enemy.maxHp * 0.6,
                    damage: enemy.damage * 0.8,
                    speed: enemy.speed * 1.3,
                    color: enemy.color,
                    goldReward: Math.floor(enemy.goldReward * 0.4),
                    expReward: Math.floor(enemy.expReward * 0.4),
                    type: 'split',
                    angle: 0
                };

                this.enemies.push(splitEnemy1, splitEnemy2);
                this.createFloatingText(enemy.x, enemy.y - 30, '分裂!', '#ff00ff');

                // 移除原敌人
                const index = this.enemies.indexOf(enemy);
                if (index > -1) {
                    this.enemies.splice(index, 1);
                }
            }

            enemySummon(enemy) {
                // 召唤小怪
                for (let i = 0; i < 2; i++) {
                    const angle = (Math.PI * 2 / 2) * i;
                    const distance = 50;

                    const summonedEnemy = {
                        x: enemy.x + Math.cos(angle) * distance,
                        y: enemy.y + Math.sin(angle) * distance,
                        radius: 10,
                        hp: 20,
                        maxHp: 20,
                        damage: 3,
                        speed: 1.5,
                        color: '#ffaa00',
                        goldReward: 5,
                        expReward: 5,
                        type: 'summoned',
                        angle: 0
                    };

                    this.enemies.push(summonedEnemy);
                }

                this.createFloatingText(enemy.x, enemy.y - 30, '召唤!', '#ffaa00');
                this.createParticle(enemy.x, enemy.y, '#ffaa00', 20);
            }

            enemyRage(enemy, currentTime) {
                // 狂暴状态
                enemy.isRaging = true;
                enemy.rageEndTime = currentTime + 5000; // 持续5秒
                enemy.damage *= 1.5; // 伤害增加50%

                this.createFloatingText(enemy.x, enemy.y - 30, '狂暴!', '#ff0000');
                this.createParticle(enemy.x, enemy.y, '#ff0000', 25);
            }

            enemyLaser(enemy) {
                // 激光攻击 - 向玩家发射激光
                const dx = this.player.x - enemy.x;
                const dy = this.player.y - enemy.y;
                const dist = Math.hypot(dx, dy);

                if (dist > 0) {
                    // 创建激光投射物
                    const laser = {
                        x: enemy.x,
                        y: enemy.y,
                        vx: (dx / dist) * 12, // 激光速度很快
                        vy: (dy / dist) * 12,
                        radius: 8,
                        damage: enemy.damage * 2, // 激光伤害是普通攻击的2倍
                        color: '#00ffff',
                        piercing: 0,
                        isLaser: true
                    };

                    this.projectiles.push(laser);
                    this.createFloatingText(enemy.x, enemy.y - 30, '激光!', '#00ffff');
                    this.createParticle(enemy.x, enemy.y, '#00ffff', 15);
                }
            }

            enemyTeleport(enemy, currentTime) {
                // 传送到玩家附近的随机位置
                const angle = Math.random() * Math.PI * 2;
                const distance = 80 + Math.random() * 40; // 距离玩家80-120像素

                enemy.x = this.player.x + Math.cos(angle) * distance;
                enemy.y = this.player.y + Math.sin(angle) * distance;

                // 确保不传送到画布外
                enemy.x = Math.max(enemy.radius, Math.min(this.canvas.width - enemy.radius, enemy.x));
                enemy.y = Math.max(enemy.radius, Math.min(this.canvas.height - enemy.radius, enemy.y));

                enemy.lastTeleportTime = currentTime;

                this.createFloatingText(enemy.x, enemy.y - 30, '传送!', '#ff00ff');
                this.createParticle(enemy.x, enemy.y, '#ff00ff', 20);
            }

            enemyShield(enemy, currentTime) {
                // 护盾技能 - 吸收伤害
                enemy.hasShield = true;
                enemy.shieldEndTime = currentTime + 8000; // 护盾持续8秒
                enemy.shieldHp = enemy.maxHp * 0.3; // 护盾血量为最大血量的30%
                enemy.color = '#00ff00'; // 护盾状态下变绿色

                this.createFloatingText(enemy.x, enemy.y - 30, '护盾!', '#00ff00');
                this.createParticle(enemy.x, enemy.y, '#00ff00', 30);
            }

            enemyEarthquake(enemy, currentTime) {
                // 地震技能 - 范围伤害
                enemy.earthquakeCharging = true;
                enemy.earthquakeStartTime = currentTime;

                this.createFloatingText(enemy.x, enemy.y - 30, '蓄力中...', '#ffaa00');

                // 2秒后释放地震
                setTimeout(() => {
                    if (enemy.earthquakeCharging) {
                        const playerDist = Math.hypot(enemy.x - this.player.x, enemy.y - this.player.y);
                        if (playerDist < 150) { // 地震范围150像素
                            this.damagePlayer(enemy.damage * 1.5);
                            this.createFloatingText(this.player.x, this.player.y - 30, '地震伤害!', '#ff0000');
                        }

                        // 地震特效
                        for (let i = 0; i < 20; i++) {
                            const angle = (Math.PI * 2 / 20) * i;
                            const x = enemy.x + Math.cos(angle) * 100;
                            const y = enemy.y + Math.sin(angle) * 100;
                            this.createParticle(x, y, '#8b4513', 8);
                        }

                        this.createFloatingText(enemy.x, enemy.y - 30, '地震!', '#8b4513');
                        enemy.earthquakeCharging = false;
                    }
                }, 2000);
            }

            damageEnemy(enemy, index, damage) {
                let actualDamage = damage;

                // 检查护盾
                if (enemy.hasShield && enemy.shieldHp > 0) {
                    if (enemy.shieldHp >= damage) {
                        enemy.shieldHp -= damage;
                        actualDamage = 0;
                        this.createFloatingText(enemy.x, enemy.y - enemy.radius, `护盾-${damage}`, '#00ff00');
                    } else {
                        actualDamage = damage - enemy.shieldHp;
                        this.createFloatingText(enemy.x, enemy.y - enemy.radius, `护盾-${enemy.shieldHp}`, '#00ff00');
                        enemy.shieldHp = 0;
                        enemy.hasShield = false;
                        enemy.color = '#ff0000'; // 恢复原色
                    }
                }

                if (actualDamage > 0) {
                    enemy.hp -= actualDamage;
                    this.createFloatingText(enemy.x, enemy.y - enemy.radius, `-${actualDamage}`, '#ffff00');
                }

                if (enemy.hp <= 0) {
                    // 死亡效果
                    this.createParticle(enemy.x, enemy.y, enemy.color, 10);

                    // 奖励
                    this.kills++;
                    this.gold += enemy.goldReward;
                    this.addExp(enemy.expReward);

                    // 显示奖励
                    this.createFloatingText(enemy.x, enemy.y, `+${enemy.goldReward}G`, '#ffff00');

                    this.enemies.splice(index, 1);
                }
            }
            
            damagePlayer(damage) {
                this.player.hp -= damage;
                
                // 显示伤害
                this.createFloatingText(this.player.x, this.player.y - 30, `-${damage}`, '#ff0000');
                
                if (this.player.hp <= 0) {
                    this.gameOver();
                }
            }
            
            addExp(amount) {
                this.exp += amount;
                
                while (this.exp >= this.expNeeded) {
                    this.exp -= this.expNeeded;
                    this.level++;
                    this.expNeeded = Math.floor(this.expNeeded * 1.2);
                    
                    // 升级奖励
                    this.player.maxHp += 20;
                    this.player.hp = this.player.maxHp;
                    this.player.damage += 5;
                    this.player.attackSpeed += 0.1;
                    
                    // 升级特效
                    this.createParticle(this.player.x, this.player.y, '#00ff00', 20);
                    this.createFloatingText(this.player.x, this.player.y - 50, 'LEVEL UP!', '#00ff00');
                }
            }
            
            upgradePlayer(stat) {
                const cost = this.upgradeCosts[stat];
                const currentLevel = this.upgradeLevels[stat];
                const maxLevel = this.upgradeMaxLevels[stat];

                // 检查是否达到升级上限
                if (currentLevel >= maxLevel) {
                    return;
                }

                if (this.gold >= cost) {
                    this.gold -= cost;
                    this.upgradeLevels[stat]++;

                    switch(stat) {
                        case 'damage':
                            this.player.damage += 10;
                            this.upgradeCosts.damage = Math.floor(this.upgradeCosts.damage * 1.3);
                            break;
                        case 'attackSpeed':
                            this.player.attackSpeed += 0.5;
                            this.upgradeCosts.attackSpeed = Math.floor(this.upgradeCosts.attackSpeed * 1.3);
                            break;
                        case 'maxHp':
                            this.player.maxHp += 50;
                            this.player.hp += 50;
                            this.upgradeCosts.maxHp = Math.floor(this.upgradeCosts.maxHp * 1.3);
                            break;
                        case 'range':
                            this.player.range += 20;
                            this.upgradeCosts.range = Math.floor(this.upgradeCosts.range * 1.3);
                            break;
                        case 'regen':
                            this.player.regen += 1;
                            this.upgradeCosts.regen = Math.floor(this.upgradeCosts.regen * 1.3);
                            break;
                        case 'bulletCount':
                            this.player.bulletCount += 1;
                            this.upgradeCosts.bulletCount = Math.floor(this.upgradeCosts.bulletCount * 1.5);
                            break;
                        case 'maxAmmo':
                            this.player.maxAmmo += 10;
                            this.player.ammo += 10;
                            this.upgradeCosts.maxAmmo = Math.floor(this.upgradeCosts.maxAmmo * 1.3);
                            break;
                        case 'reloadSpeed':
                            this.player.reloadSpeed = Math.floor(this.player.reloadSpeed * 0.8);
                            this.upgradeCosts.reloadSpeed = Math.floor(this.upgradeCosts.reloadSpeed * 1.4);
                            break;
                    }

                    this.updateUpgradeButtons();
                    this.updateUI();
                }
            }
            
            showUpgradeMenu() {
                document.getElementById('upgradeMenu').style.display = 'block';
                document.getElementById('upgradeBtn').classList.add('active');
                this.updateUpgradeButtons();
            }
            
            hideUpgradeMenu() {
                document.getElementById('upgradeMenu').style.display = 'none';
                document.getElementById('upgradeBtn').classList.remove('active');
            }
            
            updateUpgradeButtons() {
                // 更新按钮文本，显示等级信息
                const damageMaxText = this.upgradeMaxLevels.damage === 999 ? '∞' : this.upgradeMaxLevels.damage;
                const hpMaxText = this.upgradeMaxLevels.maxHp === 999 ? '∞' : this.upgradeMaxLevels.maxHp;
                const regenMaxText = this.upgradeMaxLevels.regen === 999 ? '∞' : this.upgradeMaxLevels.regen;
                const ammoMaxText = this.upgradeMaxLevels.maxAmmo === 999 ? '∞' : this.upgradeMaxLevels.maxAmmo;

                document.getElementById('upgradeDamage').textContent = `攻击力 +10 [${this.upgradeLevels.damage}/${damageMaxText}] (${this.upgradeCosts.damage}金币)`;
                document.getElementById('upgradeSpeed').textContent = `攻速 +0.5 [${this.upgradeLevels.attackSpeed}/${this.upgradeMaxLevels.attackSpeed}] (${this.upgradeCosts.attackSpeed}金币)`;
                document.getElementById('upgradeHp').textContent = `生命值 +50 [${this.upgradeLevels.maxHp}/${hpMaxText}] (${this.upgradeCosts.maxHp}金币)`;
                document.getElementById('upgradeRange').textContent = `射程 +20 [${this.upgradeLevels.range}/${this.upgradeMaxLevels.range}] (${this.upgradeCosts.range}金币)`;
                document.getElementById('upgradeRegen').textContent = `生命回复 +1 [${this.upgradeLevels.regen}/${regenMaxText}] (${this.upgradeCosts.regen}金币)`;
                document.getElementById('upgradeBullets').textContent = `子弹数量 +1 [${this.upgradeLevels.bulletCount}/${this.upgradeMaxLevels.bulletCount}] (${this.upgradeCosts.bulletCount}金币)`;
                document.getElementById('upgradeAmmo').textContent = `弹匣容量 +10 [${this.upgradeLevels.maxAmmo}/${ammoMaxText}] (${this.upgradeCosts.maxAmmo}金币)`;
                document.getElementById('upgradeReload').textContent = `换弹速度 +20% [${this.upgradeLevels.reloadSpeed}/${this.upgradeMaxLevels.reloadSpeed}] (${this.upgradeCosts.reloadSpeed}金币)`;

                // 更新按钮状态 - 检查金币和等级上限
                document.getElementById('upgradeDamage').disabled = this.gold < this.upgradeCosts.damage || this.upgradeLevels.damage >= this.upgradeMaxLevels.damage;
                document.getElementById('upgradeSpeed').disabled = this.gold < this.upgradeCosts.attackSpeed || this.upgradeLevels.attackSpeed >= this.upgradeMaxLevels.attackSpeed;
                document.getElementById('upgradeHp').disabled = this.gold < this.upgradeCosts.maxHp || this.upgradeLevels.maxHp >= this.upgradeMaxLevels.maxHp;
                document.getElementById('upgradeRange').disabled = this.gold < this.upgradeCosts.range || this.upgradeLevels.range >= this.upgradeMaxLevels.range;
                document.getElementById('upgradeRegen').disabled = this.gold < this.upgradeCosts.regen || this.upgradeLevels.regen >= this.upgradeMaxLevels.regen;
                document.getElementById('upgradeBullets').disabled = this.gold < this.upgradeCosts.bulletCount || this.upgradeLevels.bulletCount >= this.upgradeMaxLevels.bulletCount;
                document.getElementById('upgradeAmmo').disabled = this.gold < this.upgradeCosts.maxAmmo || this.upgradeLevels.maxAmmo >= this.upgradeMaxLevels.maxAmmo;
                document.getElementById('upgradeReload').disabled = this.gold < this.upgradeCosts.reloadSpeed || this.upgradeLevels.reloadSpeed >= this.upgradeMaxLevels.reloadSpeed;

                // 为达到上限的按钮添加特殊样式
                const buttons = ['upgradeDamage', 'upgradeSpeed', 'upgradeHp', 'upgradeRange', 'upgradeRegen', 'upgradeBullets', 'upgradeAmmo', 'upgradeReload'];
                const stats = ['damage', 'attackSpeed', 'maxHp', 'range', 'regen', 'bulletCount', 'maxAmmo', 'reloadSpeed'];

                buttons.forEach((buttonId, index) => {
                    const button = document.getElementById(buttonId);
                    const stat = stats[index];
                    if (this.upgradeLevels[stat] >= this.upgradeMaxLevels[stat]) {
                        button.style.backgroundColor = '#666';
                        button.style.color = '#999';
                        button.textContent = button.textContent.replace(/\(.*?\)/, '(已满级)');
                    } else {
                        button.style.backgroundColor = '';
                        button.style.color = '';
                    }
                });
            }
            
            updateUI() {
                document.getElementById('wave').textContent = this.wave;
                document.getElementById('kills').textContent = this.kills;
                document.getElementById('gold').textContent = this.gold;
                document.getElementById('exp').textContent = this.exp;
                document.getElementById('expNeeded').textContent = this.expNeeded;
                document.getElementById('level').textContent = this.level;
                document.getElementById('hp').textContent = Math.max(0, Math.floor(this.player.hp));
                document.getElementById('maxHp').textContent = this.player.maxHp;
                document.getElementById('damage').textContent = this.player.damage;
                document.getElementById('attackSpeed').textContent = this.player.attackSpeed.toFixed(1);
                document.getElementById('range').textContent = Math.floor(this.player.range);
                document.getElementById('regen').textContent = this.player.regen;
                document.getElementById('bulletCount').textContent = this.player.bulletCount;
                document.getElementById('ammo').textContent = this.player.ammo;
                document.getElementById('maxAmmo').textContent = this.player.maxAmmo;
                
                // 更新弹药条
                const ammoPercent = this.player.ammo / this.player.maxAmmo;
                document.getElementById('ammoBar').style.width = `${ammoPercent * 100}%`;
            }
            
            gameOver() {
                this.isPaused = true;
                document.getElementById('finalDifficulty').textContent = this.difficultySettings[this.difficulty].name;
                document.getElementById('finalWave').textContent = this.wave;
                document.getElementById('finalKills').textContent = this.kills;
                document.getElementById('finalLevel').textContent = this.level;
                document.getElementById('gameOver').style.display = 'block';
            }
            
            render() {
                // 清空画布
                this.ctx.fillStyle = '#1a1a1a';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                if (!this.isGameStarted) return;
                
                // 绘制网格
                this.drawGrid();
                
                // 绘制攻击范围
                this.ctx.strokeStyle = 'rgba(0, 255, 0, 0.2)';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.arc(this.player.x, this.player.y, this.player.range, 0, Math.PI * 2);
                this.ctx.stroke();
                
                // 绘制玩家
                this.ctx.fillStyle = this.player.isReloading ? '#888888' : this.player.color;
                this.ctx.beginPath();
                this.ctx.arc(this.player.x, this.player.y, this.player.radius, 0, Math.PI * 2);
                this.ctx.fill();
                
                // 绘制玩家血条
                const hpPercent = this.player.hp / this.player.maxHp;
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(this.player.x - 25, this.player.y - 35, 50, 5);
                this.ctx.fillStyle = hpPercent > 0.5 ? '#0f0' : hpPercent > 0.25 ? '#ff0' : '#f00';
                this.ctx.fillRect(this.player.x - 25, this.player.y - 35, 50 * hpPercent, 5);
                
                // 绘制换弹进度
                if (this.player.isReloading) {
                    const reloadProgress = (Date.now() - this.player.reloadStartTime) / this.player.reloadSpeed;
                    this.ctx.fillStyle = '#000';
                    this.ctx.fillRect(this.player.x - 25, this.player.y + 30, 50, 3);
                    this.ctx.fillStyle = '#00ffff';
                    this.ctx.fillRect(this.player.x - 25, this.player.y + 30, 50 * reloadProgress, 3);
                }
                
                // 绘制敌人
                for (const enemy of this.enemies) {
                    // 敌人身体
                    this.ctx.fillStyle = enemy.color;
                    this.ctx.beginPath();
                    
                    if (enemy.type === 'boss') {
                        // Boss用星形
                        this.drawStar(enemy.x, enemy.y, enemy.radius, enemy.radius * 0.5, 8);
                    } else if (enemy.type === 'elite') {
                        // 精英用六边形
                        this.drawPolygon(enemy.x, enemy.y, enemy.radius, 6);
                    } else if (enemy.type === 'tank') {
                        // 坦克用方形
                        this.ctx.fillRect(enemy.x - enemy.radius, enemy.y - enemy.radius, enemy.radius * 2, enemy.radius * 2);
                    } else {
                        // 普通敌人用圆形
                        this.ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
                    }
                    this.ctx.fill();
                    
                    // 敌人血条
                    const enemyHpPercent = enemy.hp / enemy.maxHp;
                    this.ctx.fillStyle = '#000';
                    this.ctx.fillRect(enemy.x - enemy.radius, enemy.y - enemy.radius - 10, enemy.radius * 2, 4);
                    this.ctx.fillStyle = enemyHpPercent > 0.5 ? '#0f0' : enemyHpPercent > 0.25 ? '#ff0' : '#f00';
                    this.ctx.fillRect(enemy.x - enemy.radius, enemy.y - enemy.radius - 10, enemy.radius * 2 * enemyHpPercent, 4);
                }
                
                // 绘制投射物
                for (const proj of this.projectiles) {
                    this.ctx.fillStyle = proj.color;
                    this.ctx.beginPath();
                    this.ctx.arc(proj.x, proj.y, proj.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                // 绘制粒子
                for (const particle of this.particles) {
                    this.ctx.fillStyle = particle.color;
                    this.ctx.globalAlpha = particle.life;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                this.ctx.globalAlpha = 1;
                
                // 绘制浮动文字
                for (const text of this.floatingTexts) {
                    this.ctx.fillStyle = text.color;
                    this.ctx.globalAlpha = text.life;
                    this.ctx.font = 'bold 16px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(text.text, text.x, text.y);
                }
                this.ctx.globalAlpha = 1;
            }
            
            drawGrid() {
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                this.ctx.lineWidth = 1;
                
                const gridSize = 50;
                
                for (let x = 0; x < this.canvas.width; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                
                for (let y = 0; y < this.canvas.height; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
            }
            
            drawPolygon(x, y, radius, sides) {
                this.ctx.beginPath();
                for (let i = 0; i < sides; i++) {
                    const angle = (i / sides) * Math.PI * 2 - Math.PI / 2;
                    const px = x + Math.cos(angle) * radius;
                    const py = y + Math.sin(angle) * radius;
                    if (i === 0) {
                        this.ctx.moveTo(px, py);
                    } else {
                        this.ctx.lineTo(px, py);
                    }
                }
                this.ctx.closePath();
            }
            
            drawStar(x, y, outerRadius, innerRadius, points) {
                this.ctx.beginPath();
                for (let i = 0; i < points * 2; i++) {
                    const angle = (i / (points * 2)) * Math.PI * 2 - Math.PI / 2;
                    const radius = i % 2 === 0 ? outerRadius : innerRadius;
                    const px = x + Math.cos(angle) * radius;
                    const py = y + Math.sin(angle) * radius;
                    if (i === 0) {
                        this.ctx.moveTo(px, py);
                    } else {
                        this.ctx.lineTo(px, py);
                    }
                }
                this.ctx.closePath();
            }
            
            gameLoop() {
                const currentTime = Date.now();
                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;
                
                this.update(deltaTime);
                this.render();
                
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // 启动游戏
        const game = new DefenseGame();
    </script>
</body>
</html>