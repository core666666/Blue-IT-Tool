<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D é˜²å®ˆæ¸¸æˆ</title>
    <!-- å¼•å…¥Font Awesomeå›¾æ ‡åº“ -->
    <!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"> -->
     <!-- å¼•å…¥å›¾æ ‡åº“ -->
    <link rel="stylesheet" href="allmin.css" />
    <!-- Umami ç»Ÿè®¡è„šæœ¬å»¶è¿ŸåŠ è½½å™¨ -->
    <script src="scripts/umami-loader.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #222;
        }
        #gameCanvas {   
            display: block;
            background: #1a1a1a;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 5px;
            font-size: 14px;
            border: 2px solid #444;
            z-index: 10;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            display: none;
            border: 2px solid #f00;
            z-index: 1000;
        }
        #gameOver button {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
        }
        #gameOver button:hover {
            background: #45a049;
        }
        .stat-line {
            margin: 5px 0;
        }
        .stat-value {
            color: #0f0;
            font-weight: bold;
        }
        #upgradeMenu {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 5px;
            display: none;
            border: 2px solid #0f0;
            z-index: 100;
        }
        .upgrade-btn {
            margin: 5px;
            padding: 8px 15px;
            cursor: pointer;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 3px;
            font-size: 12px;
        }
        .upgrade-btn:hover {
            background: #45a049;
        }
        .upgrade-btn:disabled {
            background: #666;
            cursor: not-allowed;
        }
        #waveNotice {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff0;
            font-size: 48px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            display: none;
            pointer-events: none;
            z-index: 50;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 600; /* ç¡®ä¿æ§åˆ¶æŒ‰é’®åœ¨æš‚åœé®ç½©ä¹‹ä¸Š */
        }
        .control-btn {
            padding: 10px 20px;
            background: #333;
            color: white;
            border: 2px solid #666;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        .control-btn:hover {
            background: #444;
            border-color: #888;
        }
        .control-btn.active {
            background: #4CAF50;
            border-color: #45a049;
        }
        #difficultyMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px;
            border-radius: 10px;
            border: 2px solid #0f0;
            text-align: center;
            z-index: 1000;
        }
        #difficultyMenu h2 {
            color: white;
            margin-bottom: 20px;
        }
        .difficulty-btn {
            display: block;
            width: 200px;
            margin: 10px auto;
            padding: 15px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        .difficulty-btn:hover {
            background: #45a049;
        }
        .difficulty-desc {
            color: #fcfafa;
            font-size: 13px;
            margin-top: 5px;
        }
        #pauseOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 500; /* åœ¨æ§åˆ¶æŒ‰é’®ä¹‹ä¸‹ */
        }
        #pauseOverlay h2 {
            color: white;
            font-size: 48px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        .ammo-bar {
            margin-top: 10px;
            background: #333;
            height: 20px;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #666;
        }
        .ammo-fill {
            height: 100%;
            background: linear-gradient(to right, #00ff00, #00aa00);
            transition: width 0.3s;
        }
        #skillInfo {
            position: absolute;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 5px;
            display: none;
            border: 2px solid #ff0;
            z-index: 100;
        }

        .nav-button {
            background: rgba(0, 100, 200, 0.8);
            padding: 8px 12px;
            border-radius: 5px;
            margin-bottom: 5px;
            transition: background 0.3s;
            border: 1px solid #0066cc;
        }

        .nav-button:hover {
            background: rgba(0, 120, 220, 0.9);
            border-color: #0088ff;
        }

        .nav-button a:hover {
            color: #fff !important;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="difficultyMenu" style="height: 80vh; overflow: hidden; display: flex; flex-direction: column;">
        <!-- é¡¶éƒ¨æ ‡é¢˜åŒºåŸŸ -->
        <div style="text-align: center; padding: 20px 0; background: rgba(0,0,0,0.9); color: white;">
            <h1 style="color: #ffff00; margin: 0; font-size: 28px;">ğŸ® æ— é™é˜²å®ˆ</h1>
            <p style="margin: 10px 0 0 0; font-size: 18px;"><strong>ç›®æ ‡ï¼š</strong>åœ¨æ— å°½çš„æ€ªç‰©æ³¢æ¬¡ä¸­ç”Ÿå­˜ä¸‹å»ï¼</p>
        </div>

        <!-- ä¸»è¦å†…å®¹åŒºåŸŸ -->
        <div style="display: flex; flex: 1; overflow: hidden;">
            <!-- å·¦ä¾§ï¼šæ¸¸æˆè¯´æ˜ -->
            <div style="flex: 1; background: rgba(0,0,0,0.8); padding: 15px; color: white; text-align: left; overflow: hidden; border-right: 2px solid #333;">
                <!-- åŒåˆ—å¸ƒå±€å®¹å™¨ -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; height: 100%;">
                    <!-- å·¦åˆ— -->
                    <div>
                        <h3 style="color: #00ff00; font-size: 16px; margin: 0 0 8px 0;">âš”ï¸ æˆ˜æ–—ç³»ç»Ÿ</h3>
                        <ul style="font-size: 14px; margin: 0 0 15px 0; padding-left: 15px;">
                            <li>è‡ªåŠ¨æ”»å‡»èŒƒå›´å†…æœ€è¿‘çš„æ•Œäºº</li>
                            <li>å¼¹è¯æœ‰é™ï¼ŒåŠæ—¶æ¢å¼¹ï¼ˆRé”®ï¼‰</li>
                            <li>æ¯æ³¢ç»“æŸåå‡çº§å±æ€§</li>
                        </ul>

                        <h3 style="color: #ff00ff; font-size: 16px; margin: 0 0 8px 0;">ğŸ¯ æ“ä½œè¯´æ˜</h3>
                        <ul style="font-size: 14px; margin: 0 0 15px 0; padding-left: 15px;">
                            <li><strong>Pé”®</strong> - æš‚åœ/ç»§ç»­</li>
                            <li><strong>Ué”®</strong> - å‡çº§é¢æ¿</li>
                            <li><strong>Ré”®</strong> - æ‰‹åŠ¨æ¢å¼¹</li>
                            <li><strong>å€é€ŸæŒ‰é’®</strong> - 1x/2x/3xé€Ÿåº¦</li>
                        </ul>

                        <h3 style="color: #ffff00; font-size: 16px; margin: 0 0 8px 0;">ï¿½ å‡çº§é™åˆ¶</h3>
                        <ul style="font-size: 14px; margin: 0; padding-left: 15px;">
                            <li><strong>æ”»é€Ÿ</strong> - æœ€å¤š15çº§</li>
                            <li><strong>å­å¼¹æ•°é‡</strong> - æœ€å¤š2çº§</li>
                            <li><strong>å°„ç¨‹</strong> - æœ€å¤š10çº§</li>
                            <li><strong>æ¢å¼¹é€Ÿåº¦</strong> - æœ€å¤š8çº§</li>
                        </ul>
                    </div>

                    <!-- å³åˆ— -->
                    <div>
                        <h3 style="color: #ff8800; font-size: 16px; margin: 0 0 8px 0;">ğŸ‘¹ æ•Œäººç±»å‹</h3>
                        <ul style="font-size: 14px; margin: 0 0 15px 0; padding-left: 15px;">
                            <li><strong>æ™®é€šæ€ª</strong> - åŸºç¡€æ•Œäºº</li>
                            <li><strong>å¿«é€Ÿæ€ª</strong> - é€Ÿåº¦å¿«è¡€é‡å°‘</li>
                            <li><strong>å¦å…‹æ€ª</strong> - è¡€åšç§»åŠ¨æ…¢</li>
                            <li><strong>ç²¾è‹±æ€ª</strong> - æ¯5æ³¢ï¼Œæœ‰ç‰¹æŠ€</li>
                            <li><strong>Boss</strong> - æ¯10æ³¢ï¼Œå¤šç§æŠ€èƒ½</li>
                        </ul>

                        <h3 style="color: #00ffff; font-size: 16px; margin: 0 0 8px 0;">âš¡ Bossç‰¹æŠ€</h3>
                        <ul style="font-size: 14px; margin: 0; padding-left: 15px;">
                            <li><strong>å†²åˆº</strong> - å¿«é€Ÿå†²å‡»</li>
                            <li><strong>å¬å”¤</strong> - å¬å”¤å°æ€ª</li>
                            <li><strong>ç‹‚æš´</strong> - é€Ÿåº¦ä¼¤å®³å¢åŠ </li>
                            <li><strong>æ¿€å…‰</strong> - é«˜ä¼¤å®³å°„çº¿</li>
                            <li><strong>ä¼ é€</strong> - ç¬ç§»æ”»å‡»</li>
                            <li><strong>æŠ¤ç›¾</strong> - å¸æ”¶ä¼¤å®³</li>
                            <li><strong>åœ°éœ‡</strong> - èŒƒå›´æ”»å‡»</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- å³ä¾§ï¼šéš¾åº¦é€‰æ‹© -->
            <div style="flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; background: rgba(0,0,0,0.7); padding: 30px;">
                <h2 style="color: white; margin-bottom: 30px; text-align: center; font-size: 24px;">é€‰æ‹©éš¾åº¦</h2>

                <button class="difficulty-btn" onclick="game.selectDifficulty('kindergarten')" style="margin: 8px 0; width: 280px;">
                    å¹¼å„¿å›­
                    <div class="difficulty-desc">æ•Œäººå¾ˆå¼±ï¼Œèµ„æºä¸°å¯Œ</div>
                </button>
                <button class="difficulty-btn" onclick="game.selectDifficulty('elementary')" style="margin: 8px 0; width: 280px;">
                    å°å­¦ç”Ÿ
                    <div class="difficulty-desc">é€‚åˆæ–°æ‰‹ç»ƒä¹ </div>
                </button>
                <button class="difficulty-btn" onclick="game.selectDifficulty('middle')" style="margin: 8px 0; width: 280px;">
                    åˆä¸­ç”Ÿ
                    <div class="difficulty-desc">æ ‡å‡†éš¾åº¦</div>
                </button>
                <button class="difficulty-btn" onclick="game.selectDifficulty('high')" style="margin: 8px 0; width: 280px;">
                    é«˜ä¸­ç”Ÿ
                    <div class="difficulty-desc">éœ€è¦ä¸€å®šæŠ€å·§</div>
                </button>
                <button class="difficulty-btn" onclick="game.selectDifficulty('university')" style="margin: 8px 0; width: 280px;">
                    å¤§å­¦ç”Ÿ
                    <div class="difficulty-desc">æé™æŒ‘æˆ˜</div>
                </button>
            </div>
        </div>
    </div>
    
    <div id="pauseOverlay">
        <h2>æ¸¸æˆæš‚åœ</h2>
    </div>
    
    <div id="ui">
        <div class="nav-button">
            <a href="../index.html" style="color: #fff; text-decoration: none; display: flex; align-items: center; gap: 5px;">
                <i class="fas fa-home"></i> è¿”å›ä¸»é¡µ
            </a>
        </div>
        <hr style="margin: 10px 0; border-color: #444;">
        <div class="stat-line">éš¾åº¦: <span class="stat-value" id="difficulty">-</span></div>
        <div class="stat-line">åœ°å›¾: <span class="stat-value" id="currentMap">-</span></div>
        <div class="stat-line">æ³¢æ•°: <span class="stat-value" id="wave">1</span></div>
        <div class="stat-line">å‡»æ€æ•°: <span class="stat-value" id="kills">0</span></div>
        <div class="stat-line">é‡‘å¸: <span class="stat-value" id="gold">50</span></div>
        <div class="stat-line">ç»éªŒ: <span class="stat-value" id="exp">0</span> / <span id="expNeeded">50</span></div>
        <div class="stat-line">ç­‰çº§: <span class="stat-value" id="level">1</span></div>
        <hr>
        <div class="stat-line">ç”Ÿå‘½å€¼: <span class="stat-value" id="hp">100</span> / <span id="maxHp">100</span></div>
        <div class="stat-line">æ”»å‡»åŠ›: <span class="stat-value" id="damage">25</span></div>
        <div class="stat-line">æ”»å‡»é€Ÿåº¦: <span class="stat-value" id="attackSpeed">2.0</span>/ç§’</div>
        <div class="stat-line">æ”»å‡»èŒƒå›´: <span class="stat-value" id="range">150</span></div>
        <div class="stat-line">ç”Ÿå‘½å›å¤: <span class="stat-value" id="regen">1</span>/ç§’</div>
        <div class="stat-line">å­å¼¹æ•°é‡: <span class="stat-value" id="bulletCount">1</span></div>
        <div class="stat-line">å¼¹åŒ£å®¹é‡: <span class="stat-value" id="ammo">30</span> / <span id="maxAmmo">30</span></div>
        <div class="ammo-bar">
            <div class="ammo-fill" id="ammoBar" style="width: 100%"></div>
        </div>
    </div>
    
    <div id="controls">
        <button class="control-btn" id="pauseBtn" onclick="game.togglePause()">æš‚åœ (P)</button>
        <button class="control-btn" id="upgradeBtn" onclick="game.toggleUpgradeMenu()">å‡çº§é¢æ¿ (U)</button>
        <button class="control-btn" id="speedBtn" onclick="game.toggleSpeed()">å€é€Ÿ: 1x</button>
    </div>
    
    <div id="upgradeMenu">
        <h3 style="color: white; margin: 0 0 10px 0;">å‡çº§é¢æ¿</h3>
        <button class="upgrade-btn" id="upgradeDamage">æ”»å‡»åŠ› +10 (30é‡‘å¸)</button>
        <button class="upgrade-btn" id="upgradeSpeed">æ”»é€Ÿ +0.5 (25é‡‘å¸)</button>
        <button class="upgrade-btn" id="upgradeHp">ç”Ÿå‘½å€¼ +50 (20é‡‘å¸)</button>
        <button class="upgrade-btn" id="upgradeRange">å°„ç¨‹ +20 (35é‡‘å¸)</button>
        <button class="upgrade-btn" id="upgradeRegen">ç”Ÿå‘½å›å¤ +1 (40é‡‘å¸)</button>
        <button class="upgrade-btn" id="upgradeBullets">å­å¼¹æ•°é‡ +1 (100é‡‘å¸)</button>
        <button class="upgrade-btn" id="upgradeAmmo">å¼¹åŒ£å®¹é‡ +10 (50é‡‘å¸)</button>
        <button class="upgrade-btn" id="upgradeReload">æ¢å¼¹é€Ÿåº¦ +20% (60é‡‘å¸)</button>
    </div>
    
    <div id="skillInfo"></div>
    
    <div id="waveNotice"></div>
    
    <div id="gameOver">
        <h2>æ¸¸æˆç»“æŸï¼</h2>
        <p>éš¾åº¦: <span id="finalDifficulty">-</span></p>
        <p>ä½ åšæŒåˆ°äº†ç¬¬ <span id="finalWave">1</span> æ³¢</p>
        <p>æ€»å‡»æ€æ•°: <span id="finalKills">0</span></p>
        <p>æœ€é«˜ç­‰çº§: <span id="finalLevel">1</span></p>
        <button onclick="location.reload()">é‡æ–°å¼€å§‹</button>
    </div>

    <script>
        class DefenseGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');

                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;

                // åŠ è½½ç²¾çµå›¾ç‰‡
                this.playerSprite = new Image();
                this.playerSprite.src = '../assets/images/InfiniteDefense/renwu.png';
                this.spriteLoaded = false;

                // åŠ è½½bossç²¾çµå›¾ç‰‡
                this.bossSprites = {
                    boss: new Image(),
                    bigboss: new Image(),
                    xiaoboss: new Image(),
                    xiaoboss1: new Image(),
                    xiaoboss2: new Image()
                };

                this.bossSprites.boss.src = '../assets/images/InfiniteDefense/boss.png';
                this.bossSprites.bigboss.src = '../assets/images/InfiniteDefense/bigboss.png';
                this.bossSprites.xiaoboss.src = '../assets/images/InfiniteDefense/xiaoboss.png';
                this.bossSprites.xiaoboss1.src = '../assets/images/InfiniteDefense/xiaoboss1.png';
                this.bossSprites.xiaoboss2.src = '../assets/images/InfiniteDefense/xiaoboss2.png';

                this.bossSpritesLoaded = {
                    boss: false,
                    bigboss: false,
                    xiaoboss: false,
                    xiaoboss1: false,
                    xiaoboss2: false
                };

                // åŠ è½½åŸºç¡€æ•Œäººç²¾çµå›¾ç‰‡
                this.enemySprite = new Image();
                this.enemySprite.src = '../assets/images/InfiniteDefense/image1.png';
                this.enemySpriteLoaded = false;

                // åŠ è½½å­å¼¹ç²¾çµå›¾ç‰‡
                this.bulletSprite = new Image();
                this.bulletSprite.src = '../assets/images/InfiniteDefense/zidan.png';
                this.bulletSpriteLoaded = false;

                // åŠ è½½èƒŒæ™¯åœ°å›¾
                this.backgroundImages = {
                    bg1: new Image(),
                    bg2: new Image()
                };

                this.backgroundImages.bg1.src = '../assets/images/InfiniteDefense/bg1.png';
                this.backgroundImages.bg2.src = '../assets/images/InfiniteDefense/bg2.png';

                this.backgroundsLoaded = {
                    bg1: false,
                    bg2: false
                };

                // éšæœºé€‰æ‹©æœ¬å±€æ¸¸æˆçš„èƒŒæ™¯
                const backgroundOptions = ['bg1', 'bg2'];
                this.currentBackground = backgroundOptions[Math.floor(Math.random() * backgroundOptions.length)];

                // ç²¾çµåæ ‡å®šä¹‰
                this.sprites = {
                    player: { x: 149, y: 344, width: 255, height: 369 },
                    player1: { x: 407, y: 233, width: 342, height: 556 },
                    // boss.png ä¸­çš„bossç²¾çµ
                    boss1: { x: 40, y: 44, width: 446, height: 445 },
                    boss2: { x: 516, y: 57, width: 472, height: 426 },
                    boss3: { x: 20, y: 522, width: 482, height: 437 },
                    boss4: { x: 506, y: 519, width: 455, height: 475 },
                    // bigboss.png æ˜¯å•å¼ å›¾ç‰‡ï¼Œæ•´ä¸ªå›¾ç‰‡å°±æ˜¯boss
                    bigboss: { x: 0, y: 0, width: 0, height: 0 }, // å°†åœ¨å›¾ç‰‡åŠ è½½åè®¾ç½®
                    // xiaoboss.png ä¸­çš„boss
                    xiaoboss: { x: 277, y: 223, width: 464, height: 577 },
                    // xiaoboss1.png ä¸­çš„boss
                    xiaoboss1: { x: 309, y: 246, width: 408, height: 508 },
                    // xiaoboss2.png ä¸­çš„bossç²¾çµ
                    xiaoboss2_1: { x: 24, y: 45, width: 447, height: 449 },
                    xiaoboss2_2: { x: 502, y: 34, width: 490, height: 482 },
                    xiaoboss2_3: { x: 25, y: 530, width: 479, height: 476 },
                    xiaoboss2_4: { x: 522, y: 520, width: 484, height: 489 },
                    // image1.png ä¸­çš„åŸºç¡€æ•Œäººç²¾çµ
                    enemy1: { x: 287, y: 325, width: 194, height: 228 },
                    enemy2: { x: 53, y: 329, width: 198, height: 224 },
                    enemy3: { x: 771, y: 57, width: 185, height: 221 },
                    enemy4: { x: 51, y: 63, width: 214, height: 227 },
                    enemy5: { x: 281, y: 65, width: 220, height: 220 },
                    enemy6: { x: 527, y: 62, width: 186, height: 228 },
                    enemy7: { x: 522, y: 325, width: 187, height: 218 },
                    enemy8: { x: 780, y: 329, width: 175, height: 218 },
                    enemy9: { x: 54, y: 588, width: 203, height: 218 },
                    enemy10: { x: 276, y: 584, width: 214, height: 229 },
                    enemy11: { x: 519, y: 581, width: 196, height: 230 },
                    enemy12: { x: 769, y: 587, width: 190, height: 220 },
                    // zidan.png ä¸­çš„å­å¼¹ç²¾çµ
                    bullet1: { x: 412, y: 137, width: 262, height: 163 },
                    bullet2: { x: 714, y: 132, width: 250, height: 166 },
                    bullet3: { x: 108, y: 389, width: 264, height: 138 },
                    bullet4: { x: 716, y: 365, width: 240, height: 171 }
                };

                this.playerSprite.onload = () => {
                    this.spriteLoaded = true;
                };

                // è®¾ç½®bosså›¾ç‰‡åŠ è½½å›è°ƒ
                this.bossSprites.boss.onload = () => {
                    this.bossSpritesLoaded.boss = true;
                };
                this.bossSprites.bigboss.onload = () => {
                    this.bossSpritesLoaded.bigboss = true;
                    // bigbossæ˜¯å•å¼ å›¾ç‰‡ï¼Œè®¾ç½®å…¶å®Œæ•´å°ºå¯¸
                    this.sprites.bigboss.width = this.bossSprites.bigboss.width;
                    this.sprites.bigboss.height = this.bossSprites.bigboss.height;
                };
                this.bossSprites.xiaoboss.onload = () => {
                    this.bossSpritesLoaded.xiaoboss = true;
                };
                this.bossSprites.xiaoboss1.onload = () => {
                    this.bossSpritesLoaded.xiaoboss1 = true;
                };
                this.bossSprites.xiaoboss2.onload = () => {
                    this.bossSpritesLoaded.xiaoboss2 = true;
                };

                this.enemySprite.onload = () => {
                    this.enemySpriteLoaded = true;
                };

                this.bulletSprite.onload = () => {
                    this.bulletSpriteLoaded = true;
                };

                // è®¾ç½®èƒŒæ™¯å›¾ç‰‡åŠ è½½å›è°ƒ
                this.backgroundImages.bg1.onload = () => {
                    this.backgroundsLoaded.bg1 = true;
                };

                this.backgroundImages.bg2.onload = () => {
                    this.backgroundsLoaded.bg2 = true;
                };

                // ä¸ºæœ¬å±€æ¸¸æˆéšæœºé€‰æ‹©ä¸€ç§å­å¼¹ç±»å‹
                const bulletVariants = ['bullet1', 'bullet2', 'bullet3', 'bullet4'];
                this.gameBulletVariant = bulletVariants[Math.floor(Math.random() * bulletVariants.length)];

                // äººç‰©å½¢è±¡åˆ‡æ¢ç‰¹æ•ˆç³»ç»Ÿ
                this.currentPlayerForm = 'player'; // å½“å‰äººç‰©å½¢æ€
                this.transformEffect = {
                    active: false,
                    startTime: 0,
                    duration: 2000, // ç‰¹æ•ˆæŒç»­2ç§’
                    particles: []
                };
                
                // éš¾åº¦è®¾ç½®
                this.difficulty = null;
                this.difficultySettings = {
                    kindergarten: {
                        name: 'å¹¼å„¿å›­',
                        enemyHpMultiplier: 0.5,
                        enemyDamageMultiplier: 0.5,
                        enemySpeedMultiplier: 0.7,
                        goldMultiplier: 2,
                        expMultiplier: 1.5,
                        startGold: 100
                    },
                    elementary: {
                        name: 'å°å­¦ç”Ÿ',
                        enemyHpMultiplier: 0.75,
                        enemyDamageMultiplier: 0.75,
                        enemySpeedMultiplier: 0.85,
                        goldMultiplier: 1.5,
                        expMultiplier: 1.25,
                        startGold: 75
                    },
                    middle: {
                        name: 'åˆä¸­ç”Ÿ',
                        enemyHpMultiplier: 1,
                        enemyDamageMultiplier: 1,
                        enemySpeedMultiplier: 1,
                        goldMultiplier: 1,
                        expMultiplier: 1,
                        startGold: 50
                    },
                    high: {
                        name: 'é«˜ä¸­ç”Ÿ',
                        enemyHpMultiplier: 1.5,
                        enemyDamageMultiplier: 1.5,
                        enemySpeedMultiplier: 1.2,
                        goldMultiplier: 0.8,
                        expMultiplier: 0.9,
                        startGold: 30
                    },
                    university: {
                        name: 'å¤§å­¦ç”Ÿ',
                        enemyHpMultiplier: 2,
                        enemyDamageMultiplier: 2,
                        enemySpeedMultiplier: 1.5,
                        goldMultiplier: 0.6,
                        expMultiplier: 0.8,
                        startGold: 20
                    }
                };
                
                this.player = {
                    x: this.canvas.width / 2,
                    y: this.canvas.height / 2,
                    radius: 20,
                    hp: 100,
                    maxHp: 100,
                    damage: 25,
                    attackSpeed: 2.0,
                    range: 150,
                    regen: 1,
                    bulletCount: 1,
                    ammo: 30,
                    maxAmmo: 30,
                    reloadSpeed: 2000, // 2ç§’æ¢å¼¹
                    isReloading: false,
                    reloadStartTime: 0,
                    color: '#00ff00',
                    lastAttackTime: 0,
                    lastRegenTime: 0
                };
                
                this.enemies = [];
                this.projectiles = [];
                this.particles = [];
                this.floatingTexts = [];
                
                this.wave = 1;
                this.enemiesInWave = 0;
                this.enemiesSpawned = 0;
                this.kills = 0;
                this.gold = 50;
                this.exp = 0;
                this.level = 1;
                this.expNeeded = 50;
                
                this.isPaused = false;
                this.isGameStarted = false;
                this.isWaveComplete = false;
                this.lastTime = 0;
                this.spawnTimer = 0;
                this.gameSpeed = 1; // æ¸¸æˆå€é€Ÿ
                this.speedOptions = [1, 2, 3]; // å¯é€‰å€é€Ÿ
                this.currentSpeedIndex = 0;
                
                this.upgradeCosts = {
                    damage: 30,
                    attackSpeed: 25,
                    maxHp: 20,
                    range: 35,
                    regen: 40,
                    bulletCount: 100,
                    maxAmmo: 50,
                    reloadSpeed: 60
                };

                // å‡çº§ç­‰çº§è·Ÿè¸ª
                this.upgradeLevels = {
                    damage: 0,
                    attackSpeed: 0,
                    maxHp: 0,
                    range: 0,
                    regen: 0,
                    bulletCount: 0,
                    maxAmmo: 0,
                    reloadSpeed: 0
                };

                // å‡çº§ä¸Šé™è®¾ç½®
                this.upgradeMaxLevels = {
                    damage: 999, // æ”»å‡»åŠ›å¯ä»¥æ— é™å‡çº§
                    attackSpeed: 15, // æ”»é€Ÿæœ€å¤šå‡çº§15æ¬¡
                    maxHp: 999, // ç”Ÿå‘½å€¼å¯ä»¥æ— é™å‡çº§
                    range: 10, // å°„ç¨‹æœ€å¤šå‡çº§10æ¬¡
                    regen: 999, // ç”Ÿå‘½å›å¤å¯ä»¥æ— é™å‡çº§
                    bulletCount: 2, // å­å¼¹æ•°é‡æœ€å¤šå‡çº§2æ¬¡
                    maxAmmo: 999, // å¼¹åŒ£å®¹é‡å¯ä»¥æ— é™å‡çº§
                    reloadSpeed: 8 // æ¢å¼¹é€Ÿåº¦æœ€å¤šå‡çº§8æ¬¡
                };
                
                this.init();
            }
            
            init() {
                // ç»‘å®šå‡çº§æŒ‰é’®
                document.getElementById('upgradeDamage').onclick = () => this.upgradePlayer('damage');
                document.getElementById('upgradeSpeed').onclick = () => this.upgradePlayer('attackSpeed');
                document.getElementById('upgradeHp').onclick = () => this.upgradePlayer('maxHp');
                document.getElementById('upgradeRange').onclick = () => this.upgradePlayer('range');
                document.getElementById('upgradeRegen').onclick = () => this.upgradePlayer('regen');
                document.getElementById('upgradeBullets').onclick = () => this.upgradePlayer('bulletCount');
                document.getElementById('upgradeAmmo').onclick = () => this.upgradePlayer('maxAmmo');
                document.getElementById('upgradeReload').onclick = () => this.upgradePlayer('reloadSpeed');
                
                // é”®ç›˜äº‹ä»¶
                window.addEventListener('keydown', (e) => {
                    if (e.key === 'p' || e.key === 'P') {
                        this.togglePause();
                    } else if (e.key === 'u' || e.key === 'U') {
                        this.toggleUpgradeMenu();
                    } else if (e.key === 'r' || e.key === 'R') {
                        this.reload();
                    }
                });
                
                // ç›‘å¬çª—å£å¤§å°å˜åŒ–
                window.addEventListener('resize', () => {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                    this.player.x = this.canvas.width / 2;
                    this.player.y = this.canvas.height / 2;
                });
                
                // å¼€å§‹æ¸¸æˆå¾ªç¯
                this.gameLoop();
            }
            
            selectDifficulty(difficulty) {
                this.difficulty = difficulty;
                const settings = this.difficultySettings[difficulty];
                this.gold = settings.startGold;
                this.isGameStarted = true;
                
                document.getElementById('difficultyMenu').style.display = 'none';
                document.getElementById('difficulty').textContent = settings.name;

                // æ˜¾ç¤ºåœ°å›¾é€‰æ‹©ä¿¡æ¯
                const mapNames = {
                    'bg1': 'ğŸŒ² æ£®æ—æˆ˜åœº',
                    'bg2': 'ğŸœï¸ æ²™æ¼ æˆ˜åœº'
                };
                this.createFloatingText(this.canvas.width / 2, 100,
                    `åœ°å›¾: ${mapNames[this.currentBackground]}`, '#00ff00', 3000);

                this.startWave();
                this.updateUI();
            }
            
            togglePause() {
                if (!this.isGameStarted) return;

                this.isPaused = !this.isPaused;
                const pauseOverlay = document.getElementById('pauseOverlay');
                const pauseBtn = document.getElementById('pauseBtn');

                if (this.isPaused) {
                    pauseOverlay.style.display = 'flex';
                    pauseBtn.textContent = 'ç»§ç»­ (P)';
                    pauseBtn.classList.add('active');
                } else {
                    pauseOverlay.style.display = 'none';
                    pauseBtn.textContent = 'æš‚åœ (P)';
                    pauseBtn.classList.remove('active');
                }
            }

            toggleSpeed() {
                if (!this.isGameStarted) return;

                this.currentSpeedIndex = (this.currentSpeedIndex + 1) % this.speedOptions.length;
                this.gameSpeed = this.speedOptions[this.currentSpeedIndex];
                document.getElementById('speedBtn').textContent = `å€é€Ÿ: ${this.gameSpeed}x`;
            }
            
            toggleUpgradeMenu() {
                if (!this.isGameStarted) return;
                
                const menu = document.getElementById('upgradeMenu');
                const btn = document.getElementById('upgradeBtn');
                
                if (menu.style.display === 'block') {
                    menu.style.display = 'none';
                    btn.classList.remove('active');
                } else {
                    menu.style.display = 'block';
                    btn.classList.add('active');
                    this.updateUpgradeButtons();
                }
            }
            
            reload() {
                if (this.player.ammo === this.player.maxAmmo || this.player.isReloading) return;
                
                this.player.isReloading = true;
                this.player.reloadStartTime = Date.now();
                
                this.showSkillInfo('æ¢å¼¹ä¸­...');
                
                setTimeout(() => {
                    this.player.ammo = this.player.maxAmmo;
                    this.player.isReloading = false;
                    this.hideSkillInfo();
                }, this.player.reloadSpeed);
            }
            
            showSkillInfo(text) {
                const info = document.getElementById('skillInfo');
                info.textContent = text;
                info.style.display = 'block';
            }
            
            hideSkillInfo() {
                document.getElementById('skillInfo').style.display = 'none';
            }
            
            startWave() {
                this.isWaveComplete = false;
                const config = this.getWaveConfig(this.wave);
                this.enemiesInWave = config.enemyCount;
                this.enemiesSpawned = 0;
                this.spawnTimer = 0;
                
                // æ˜¾ç¤ºæ³¢æ•°æç¤º
                this.showWaveNotice();
                
                // æ³¢æ•°å¥–åŠ±ï¼ˆä»ç¬¬2æ³¢å¼€å§‹ï¼‰
                if (this.wave > 1) {
                    const settings = this.difficultySettings[this.difficulty];
                    const bonus = Math.floor((this.wave - 1) * 15 * settings.goldMultiplier);
                    this.gold += bonus;
                    this.createFloatingText(this.player.x, this.player.y - 50, `+${bonus}é‡‘å¸`, '#ffff00');
                }
            }
            
            showWaveNotice() {
                const notice = document.getElementById('waveNotice');
                notice.textContent = `ç¬¬ ${this.wave} æ³¢`;
                notice.style.display = 'block';
                
                if (this.wave % 10 === 0) {
                    notice.style.color = '#ff0000';
                    notice.textContent += ' - BOSSæ¥è¢­ï¼';
                } else if (this.wave % 5 === 0) {
                    notice.style.color = '#ff00ff';
                    notice.textContent += ' - ç²¾è‹±æ€ªå‡ºç°ï¼';
                }
                
                setTimeout(() => {
                    notice.style.display = 'none';
                }, 2000);
            }
            
            getWaveConfig(wave) {
                // æŒ‡æ•°çº§éš¾åº¦é€’å¢ï¼Œå‰10æ³¢ç›¸å¯¹ç®€å•ï¼Œä¹‹åå¿«é€Ÿå¢é•¿
                const baseCount = wave <= 10 ? 3 + Math.floor(wave * 1.5) : 8 + Math.floor(wave * 3.0);
                const exponentialMultiplier = wave > 10 ? Math.pow(1.15, wave - 10) : 1;

                return {
                    enemyCount: Math.floor(baseCount * exponentialMultiplier * 1.5), // æé«˜50%æ€ªç‰©æ•°é‡
                    spawnDelay: Math.max(200, 1500 - wave * 50), // æ›´å¿«çš„ç”Ÿæˆé€Ÿåº¦
                    enemyHpMultiplier: 1 + (wave - 1) * 0.2 * exponentialMultiplier, // æŒ‡æ•°çº§è¡€é‡å¢é•¿
                    enemyDamageMultiplier: 1 + (wave - 1) * 0.15 * exponentialMultiplier, // æŒ‡æ•°çº§ä¼¤å®³å¢é•¿
                    enemySpeedMultiplier: 1 + Math.min((wave - 1) * 0.08, 1.5), // æ›´é«˜çš„é€Ÿåº¦ä¸Šé™
                    specialChance: Math.min(0.5, wave * 0.05), // æ›´é«˜çš„ç‰¹æ®Šæ€ªç‰©æ¦‚ç‡
                    goldMultiplier: Math.max(0.3, 1 - wave * 0.02), // é‡‘å¸è·å–é€’å‡
                    expMultiplier: Math.max(0.4, 1 - wave * 0.015) // ç»éªŒè·å–é€’å‡
                };
            }
            
            spawnEnemy() {
                const config = this.getWaveConfig(this.wave);
                let type = 'normal';
                let bossVariant = null;

                // å†³å®šæ•Œäººç±»å‹
                if (this.wave % 10 === 0 && this.enemiesSpawned === this.enemiesInWave - 1) {
                    type = 'boss';
                    // æ ¹æ®æ³¢æ¬¡å†³å®šbossç±»å‹
                    bossVariant = this.getBossVariant(this.wave);
                } else if (this.wave % 5 === 0 && this.enemiesSpawned >= this.enemiesInWave - 2) {
                    type = 'elite';
                } else if (Math.random() < config.specialChance) {
                    type = Math.random() < 0.5 ? 'fast' : 'tank';
                }

                const enemyStats = this.getEnemyStats(type, config, bossVariant);
                
                // éšæœºç”Ÿæˆä½ç½®ï¼ˆåœ¨å±å¹•è¾¹ç¼˜ï¼‰
                const side = Math.floor(Math.random() * 4);
                let x, y;
                
                switch(side) {
                    case 0: // ä¸Š
                        x = Math.random() * this.canvas.width;
                        y = -20;
                        break;
                    case 1: // å³
                        x = this.canvas.width + 20;
                        y = Math.random() * this.canvas.height;
                        break;
                    case 2: // ä¸‹
                        x = Math.random() * this.canvas.width;
                        y = this.canvas.height + 20;
                        break;
                    case 3: // å·¦
                        x = -20;
                        y = Math.random() * this.canvas.height;
                        break;
                }
                
                const enemy = {
                    x: x,
                    y: y,
                    ...enemyStats,
                    angle: 0
                };
                
                this.enemies.push(enemy);
                this.enemiesSpawned++;
            }

            // æ ¹æ®æ³¢æ¬¡å†³å®šbosså˜ä½“
            getBossVariant(wave) {
                if (wave >= 100) {
                    // è¶…é«˜æ³¢æ¬¡ï¼šå¤§boss
                    return 'bigboss';
                } else if (wave >= 50) {
                    // é«˜æ³¢æ¬¡ï¼šxiaobossç³»åˆ—
                    const variants = ['xiaoboss', 'xiaoboss1', 'xiaoboss2_1', 'xiaoboss2_2', 'xiaoboss2_3', 'xiaoboss2_4'];
                    return variants[Math.floor(Math.random() * variants.length)];
                } else if (wave >= 20) {
                    // ä¸­æ³¢æ¬¡ï¼šbossç³»åˆ—
                    const variants = ['boss1', 'boss2', 'boss3', 'boss4'];
                    return variants[Math.floor(Math.random() * variants.length)];
                } else {
                    // ä½æ³¢æ¬¡ï¼šåŸºç¡€boss
                    const variants = ['boss1', 'boss2'];
                    return variants[Math.floor(Math.random() * variants.length)];
                }
            }
            
            getEnemyStats(type, config, bossVariant = null) {
                const difficultySettings = this.difficultySettings[this.difficulty];
                
                const baseStats = {
                    normal: {
                        radius: 15,
                        hp: 30,
                        maxHp: 30,
                        damage: 5,
                        speed: 1,
                        color: '#ff0000',
                        goldReward: 10,
                        expReward: 10
                    },
                    fast: {
                        radius: 10,
                        hp: 20,
                        maxHp: 20,
                        damage: 3,
                        speed: 2,
                        color: '#ffff00',
                        goldReward: 15,
                        expReward: 15
                    },
                    tank: {
                        radius: 20,
                        hp: 80,
                        maxHp: 80,
                        damage: 8,
                        speed: 0.5,
                        color: '#8b4513',
                        goldReward: 25,
                        expReward: 20
                    },
                    elite: {
                        radius: 25,
                        hp: 150,
                        maxHp: 150,
                        damage: 12,
                        speed: 0.8,
                        color: '#ff00ff',
                        goldReward: 50,
                        expReward: 40,
                        hasSpecialAbility: true,
                        specialAbilities: ['dash', 'split'],
                        lastSpecialTime: 0,
                        specialCooldown: 3000 // 3ç§’å†·å´
                    },
                    boss: {
                        radius: 35,
                        hp: 500,
                        maxHp: 500,
                        damage: 20,
                        speed: 0.4,
                        color: '#ff0000',
                        goldReward: 150,
                        expReward: 100,
                        hasSpecialAbility: true,
                        specialAbilities: ['dash', 'summon', 'rage', 'laser', 'teleport', 'shield', 'earthquake'],
                        lastSpecialTime: 0,
                        specialCooldown: 3000, // 3ç§’å†·å´
                        isRaging: false,
                        rageEndTime: 0,
                        hasShield: false,
                        shieldEndTime: 0,
                        shieldHp: 0,
                        lastTeleportTime: 0,
                        earthquakeCharging: false,
                        earthquakeStartTime: 0
                    }
                };
                
                const stats = { ...baseStats[type], type: type };

                // ä¸ºæ‰€æœ‰ébossæ•Œäººåˆ†é…ç²¾çµå˜ä½“
                if (type !== 'boss') {
                    let enemyVariants = [];

                    if (type === 'normal') {
                        // æ™®é€šæ•Œäººï¼šä½¿ç”¨å‰6ä¸ªç²¾çµï¼ˆè¾ƒå°è¾ƒå¼±çš„å¤–è§‚ï¼‰
                        enemyVariants = ['enemy1', 'enemy2', 'enemy3', 'enemy4', 'enemy5', 'enemy6'];
                    } else if (type === 'fast') {
                        // å¿«é€Ÿæ•Œäººï¼šä½¿ç”¨ä¸­é—´4ä¸ªç²¾çµï¼ˆçœ‹èµ·æ¥æ›´æ•æ·ï¼‰
                        enemyVariants = ['enemy3', 'enemy4', 'enemy7', 'enemy8'];
                    } else if (type === 'tank') {
                        // å¦å…‹æ•Œäººï¼šä½¿ç”¨å4ä¸ªç²¾çµï¼ˆçœ‹èµ·æ¥æ›´å¼ºå£®ï¼‰
                        enemyVariants = ['enemy9', 'enemy10', 'enemy11', 'enemy12'];
                    } else if (type === 'elite') {
                        // ç²¾è‹±æ•Œäººï¼šå¯ä»¥ä½¿ç”¨bossç²¾çµä½œä¸ºå¼ºåŒ–ç‰ˆæœ¬
                        const bossVariants = ['boss1', 'boss2', 'boss3', 'boss4'];
                        enemyVariants = bossVariants;
                        stats.usesBossSprite = true; // æ ‡è®°ä½¿ç”¨bossç²¾çµ
                    } else {
                        // å…¶ä»–ç±»å‹ï¼šéšæœºé€‰æ‹©
                        enemyVariants = ['enemy1', 'enemy2', 'enemy3', 'enemy4', 'enemy5', 'enemy6',
                                        'enemy7', 'enemy8', 'enemy9', 'enemy10', 'enemy11', 'enemy12'];
                    }

                    stats.enemyVariant = enemyVariants[Math.floor(Math.random() * enemyVariants.length)];
                }

                // å¦‚æœæ˜¯bossï¼Œæ·»åŠ å˜ä½“ä¿¡æ¯å’Œè°ƒæ•´å±æ€§
                if (type === 'boss' && bossVariant) {
                    stats.bossVariant = bossVariant;

                    // æ ¹æ®bosså˜ä½“è°ƒæ•´å±æ€§
                    if (bossVariant === 'bigboss') {
                        // å¤§bossï¼šè¶…å¼ºå±æ€§
                        stats.radius = 60;
                        stats.hp *= 3;
                        stats.maxHp *= 3;
                        stats.damage *= 2;
                        stats.goldReward *= 3;
                        stats.expReward *= 3;
                    } else if (bossVariant.startsWith('xiaoboss')) {
                        // å°bossç³»åˆ—ï¼šä¸­ç­‰å¼ºåŒ–
                        stats.radius = 45;
                        stats.hp *= 2;
                        stats.maxHp *= 2;
                        stats.damage *= 1.5;
                        stats.goldReward *= 2;
                        stats.expReward *= 2;
                    } else if (bossVariant.startsWith('boss')) {
                        // æ™®é€šbossç³»åˆ—ï¼šåŸºç¡€å¼ºåŒ–
                        stats.radius = 40;
                        stats.hp *= 1.5;
                        stats.maxHp *= 1.5;
                        stats.damage *= 1.2;
                        stats.goldReward *= 1.5;
                        stats.expReward *= 1.5;
                    }
                }

                // åº”ç”¨æ³¢æ•°åŠ æˆ
                stats.hp = Math.floor(stats.hp * config.enemyHpMultiplier * difficultySettings.enemyHpMultiplier);
                stats.maxHp = Math.floor(stats.maxHp * config.enemyHpMultiplier * difficultySettings.enemyHpMultiplier);
                stats.damage = Math.floor(stats.damage * config.enemyDamageMultiplier * difficultySettings.enemyDamageMultiplier);
                stats.speed = stats.speed * config.enemySpeedMultiplier * difficultySettings.enemySpeedMultiplier;
                // åº”ç”¨æ³¢æ¬¡é€’å‡çš„é‡‘å¸å’Œç»éªŒå¥–åŠ±
                stats.goldReward = Math.floor(stats.goldReward * difficultySettings.goldMultiplier * config.goldMultiplier);
                stats.expReward = Math.floor(stats.expReward * difficultySettings.expMultiplier * config.expMultiplier);
                
                return stats;
            }
            
            createProjectile(target) {
                if (this.player.ammo <= 0 || this.player.isReloading) {
                    if (!this.player.isReloading) {
                        this.reload();
                    }
                    return;
                }
                
                const baseAngle = Math.atan2(target.y - this.player.y, target.x - this.player.x);
                
                // æ ¹æ®å­å¼¹æ•°é‡åˆ›å»ºå¤šä¸ªæŠ•å°„ç‰©
                for (let i = 0; i < this.player.bulletCount; i++) {
                    let angle = baseAngle;
                    
                    // å¤šå­å¼¹æ•£å°„
                    if (this.player.bulletCount > 1) {
                        const spread = 0.2; // æ•£å°„è§’åº¦
                        const offset = (i - (this.player.bulletCount - 1) / 2) * spread;
                        angle += offset;
                    }
                    
                    // ä½¿ç”¨æœ¬å±€æ¸¸æˆå›ºå®šçš„å­å¼¹ç±»å‹
                    this.projectiles.push({
                        x: this.player.x,
                        y: this.player.y,
                        vx: Math.cos(angle) * 10,
                        vy: Math.sin(angle) * 10,
                        damage: this.player.damage,
                        radius: 5,
                        color: '#00ffff',
                        target: target,
                        piercing: this.player.level >= 10 ? 1 : 0,
                        bulletVariant: this.gameBulletVariant, // ä½¿ç”¨å›ºå®šçš„å­å¼¹ç±»å‹
                        angle: angle // ä¿å­˜è§’åº¦ç”¨äºç²¾çµæ—‹è½¬
                    });
                }
                
                this.player.ammo--;
                
                // è‡ªåŠ¨æ¢å¼¹
                if (this.player.ammo <= 0) {
                    this.reload();
                }
            }
            
            createParticle(x, y, color, count = 5) {
                for (let i = 0; i < count; i++) {
                    const angle = (Math.PI * 2 / count) * i + Math.random() * 0.5;
                    const speed = 2 + Math.random() * 3;
                    
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        radius: 3,
                        color: color,
                        life: 1.0,
                        decay: 0.02
                    });
                }
            }
            
            createFloatingText(x, y, text, color) {
                this.floatingTexts.push({
                    x: x,
                    y: y,
                    text: text,
                    color: color,
                    vy: -2,
                    life: 1.0
                });
            }
            
            update(deltaTime) {
                if (this.isPaused || !this.isGameStarted) return;

                // åº”ç”¨å€é€Ÿ
                deltaTime *= this.gameSpeed;
                
                // ç”Ÿæˆæ•Œäºº
                if (this.enemiesSpawned < this.enemiesInWave && !this.isWaveComplete) {
                    this.spawnTimer += deltaTime;
                    const config = this.getWaveConfig(this.wave);
                    if (this.spawnTimer >= config.spawnDelay) {
                        this.spawnEnemy();
                        this.spawnTimer = 0;
                    }
                }
                
                // ç©å®¶è‡ªåŠ¨æ”»å‡»
                const currentTime = Date.now();
                const attackInterval = 1000 / this.player.attackSpeed;
                
                if (currentTime - this.player.lastAttackTime >= attackInterval && this.enemies.length > 0 && !this.player.isReloading) {
                    // æ‰¾æœ€è¿‘çš„æ•Œäºº
                    let closestEnemy = null;
                    let closestDist = this.player.range;
                    
                    for (const enemy of this.enemies) {
                        const dist = Math.hypot(enemy.x - this.player.x, enemy.y - this.player.y);
                        if (dist < closestDist) {
                            closestDist = dist;
                            closestEnemy = enemy;
                        }
                    }
                    
                    if (closestEnemy) {
                        this.createProjectile(closestEnemy);
                        this.player.lastAttackTime = currentTime;
                    }
                }
                
                // ç©å®¶ç”Ÿå‘½å›å¤
                if (currentTime - this.player.lastRegenTime >= 1000) {
                    if (this.player.hp < this.player.maxHp) {
                        this.player.hp = Math.min(this.player.hp + this.player.regen, this.player.maxHp);
                        this.player.lastRegenTime = currentTime;
                    }
                }
                
                // æ›´æ–°æ•Œäºº
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];

                    // å¤„ç†ç‰¹æ®Šèƒ½åŠ›
                    if (enemy.hasSpecialAbility) {
                        this.updateEnemySpecialAbilities(enemy, currentTime);
                    }

                    // ç§»åŠ¨å‘ç©å®¶
                    const dx = this.player.x - enemy.x;
                    const dy = this.player.y - enemy.y;
                    const dist = Math.hypot(dx, dy);

                    let moveSpeed = enemy.speed;

                    // Bossç‹‚æš´çŠ¶æ€ä¸‹é€Ÿåº¦ç¿»å€
                    if (enemy.isRaging && currentTime < enemy.rageEndTime) {
                        moveSpeed *= 2;
                        enemy.color = '#ff4444'; // ç‹‚æš´æ—¶é¢œè‰²å˜åŒ–
                    } else if (enemy.type === 'boss') {
                        enemy.color = '#ff0000'; // æ¢å¤åŸè‰²
                        enemy.isRaging = false;
                    }

                    if (dist > 0) {
                        enemy.x += (dx / dist) * moveSpeed;
                        enemy.y += (dy / dist) * moveSpeed;
                        enemy.angle = Math.atan2(dy, dx);
                    }

                    // æ£€æŸ¥ç¢°æ’ï¼ˆä½¿ç”¨åŠ¨æ€åŠå¾„ï¼‰
                    const playerRadius = this.getPlayerSize() / 2;
                    if (dist < playerRadius + enemy.radius) {
                        this.damagePlayer(enemy.damage);
                        this.createParticle(enemy.x, enemy.y, enemy.color);
                        this.enemies.splice(i, 1);
                    }
                }
                
                // æ›´æ–°æŠ•å°„ç‰©
                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    const proj = this.projectiles[i];
                    
                    proj.x += proj.vx;
                    proj.y += proj.vy;
                    
                    // æ£€æŸ¥è¾¹ç•Œ
                    if (proj.x < 0 || proj.x > this.canvas.width || 
                        proj.y < 0 || proj.y > this.canvas.height) {
                        this.projectiles.splice(i, 1);
                        continue;
                    }
                    
                    // æ£€æŸ¥ç¢°æ’
                    let hit = false;
                    for (let j = this.enemies.length - 1; j >= 0; j--) {
                        const enemy = this.enemies[j];
                        const dist = Math.hypot(enemy.x - proj.x, enemy.y - proj.y);
                        
                        if (dist < enemy.radius + proj.radius) {
                            this.damageEnemy(enemy, j, proj.damage);
                            hit = true;
                            
                            if (proj.piercing > 0) {
                                proj.piercing--;
                            } else {
                                this.projectiles.splice(i, 1);
                            }
                            break;
                        }
                    }
                }
                
                // æ›´æ–°ç²’å­
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vy += 0.2;
                    particle.life -= particle.decay;
                    
                    if (particle.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
                
                // æ›´æ–°æµ®åŠ¨æ–‡å­—
                for (let i = this.floatingTexts.length - 1; i >= 0; i--) {
                    const text = this.floatingTexts[i];
                    
                    text.y += text.vy;
                    text.life -= 0.02;
                    
                    if (text.life <= 0) {
                        this.floatingTexts.splice(i, 1);
                    }
                }
                
                // æ£€æŸ¥æ³¢æ¬¡å®Œæˆ
                if (this.enemies.length === 0 && this.enemiesSpawned >= this.enemiesInWave && !this.isWaveComplete) {
                    this.isWaveComplete = true;
                    this.showUpgradeMenu();
                    
                    setTimeout(() => {
                        this.hideUpgradeMenu();
                        this.wave++;
                        this.startWave();
                    }, 3000);
                }
                
                this.updateUI();
            }
            
            updateEnemySpecialAbilities(enemy, currentTime) {
                if (currentTime - enemy.lastSpecialTime < enemy.specialCooldown) {
                    return;
                }

                const playerDist = Math.hypot(enemy.x - this.player.x, enemy.y - this.player.y);

                // éšæœºé€‰æ‹©ä¸€ä¸ªç‰¹æŠ€
                const ability = enemy.specialAbilities[Math.floor(Math.random() * enemy.specialAbilities.length)];

                switch(ability) {
                    case 'dash':
                        if (playerDist < 200) {
                            this.enemyDash(enemy);
                            enemy.lastSpecialTime = currentTime;
                        }
                        break;
                    case 'split':
                        if (enemy.hp < enemy.maxHp * 0.5) { // è¡€é‡ä½äº50%æ—¶åˆ†è£‚
                            this.enemySplit(enemy);
                            enemy.lastSpecialTime = currentTime;
                        }
                        break;
                    case 'summon':
                        if (playerDist < 300) {
                            this.enemySummon(enemy);
                            enemy.lastSpecialTime = currentTime;
                        }
                        break;
                    case 'rage':
                        if (enemy.hp < enemy.maxHp * 0.3) { // è¡€é‡ä½äº30%æ—¶ç‹‚æš´
                            this.enemyRage(enemy, currentTime);
                            enemy.lastSpecialTime = currentTime;
                        }
                        break;
                    case 'laser':
                        if (playerDist < 400) {
                            this.enemyLaser(enemy);
                            enemy.lastSpecialTime = currentTime;
                        }
                        break;
                    case 'teleport':
                        if (playerDist < 100 && currentTime - enemy.lastTeleportTime > 8000) {
                            this.enemyTeleport(enemy, currentTime);
                            enemy.lastSpecialTime = currentTime;
                        }
                        break;
                    case 'shield':
                        if (enemy.hp < enemy.maxHp * 0.6 && !enemy.hasShield) {
                            this.enemyShield(enemy, currentTime);
                            enemy.lastSpecialTime = currentTime;
                        }
                        break;
                    case 'earthquake':
                        if (playerDist < 250 && !enemy.earthquakeCharging) {
                            this.enemyEarthquake(enemy, currentTime);
                            enemy.lastSpecialTime = currentTime;
                        }
                        break;
                }
            }

            enemyDash(enemy) {
                // å†²åˆºå‘ç©å®¶
                const dx = this.player.x - enemy.x;
                const dy = this.player.y - enemy.y;
                const dist = Math.hypot(dx, dy);

                if (dist > 0) {
                    const dashDistance = 100;
                    enemy.x += (dx / dist) * dashDistance;
                    enemy.y += (dy / dist) * dashDistance;

                    // å†²åˆºç‰¹æ•ˆ
                    this.createParticle(enemy.x, enemy.y, enemy.color, 15);
                    this.createFloatingText(enemy.x, enemy.y - 30, 'å†²åˆº!', '#ff0000');
                }
            }

            enemySplit(enemy) {
                // åˆ†è£‚æˆä¸¤ä¸ªå°æ€ªï¼Œç»§æ‰¿åŸbossçš„ç²¾çµä¿¡æ¯
                const splitEnemy1 = {
                    x: enemy.x + 30,
                    y: enemy.y,
                    radius: enemy.radius * 0.7,
                    hp: enemy.hp * 0.6,
                    maxHp: enemy.maxHp * 0.6,
                    damage: enemy.damage * 0.8,
                    speed: enemy.speed * 1.3,
                    color: enemy.color,
                    goldReward: Math.floor(enemy.goldReward * 0.4),
                    expReward: Math.floor(enemy.expReward * 0.4),
                    type: 'split',
                    angle: 0,
                    // ç»§æ‰¿åŸbossçš„ç²¾çµä¿¡æ¯
                    bossVariant: enemy.bossVariant,
                    enemyVariant: enemy.enemyVariant,
                    usesBossSprite: enemy.usesBossSprite
                };

                const splitEnemy2 = {
                    x: enemy.x - 30,
                    y: enemy.y,
                    radius: enemy.radius * 0.7,
                    hp: enemy.hp * 0.6,
                    maxHp: enemy.maxHp * 0.6,
                    damage: enemy.damage * 0.8,
                    speed: enemy.speed * 1.3,
                    color: enemy.color,
                    goldReward: Math.floor(enemy.goldReward * 0.4),
                    expReward: Math.floor(enemy.expReward * 0.4),
                    type: 'split',
                    angle: 0,
                    // ç»§æ‰¿åŸbossçš„ç²¾çµä¿¡æ¯
                    bossVariant: enemy.bossVariant,
                    enemyVariant: enemy.enemyVariant,
                    usesBossSprite: enemy.usesBossSprite
                };

                this.enemies.push(splitEnemy1, splitEnemy2);
                this.createFloatingText(enemy.x, enemy.y - 30, 'åˆ†è£‚!', '#ff00ff');

                // ç§»é™¤åŸæ•Œäºº
                const index = this.enemies.indexOf(enemy);
                if (index > -1) {
                    this.enemies.splice(index, 1);
                }
            }

            enemySummon(enemy) {
                // å¬å”¤å°æ€ªï¼Œä½¿ç”¨å°å‹ç²¾çµ
                for (let i = 0; i < 2; i++) {
                    const angle = (Math.PI * 2 / 2) * i;
                    const distance = 50;

                    // ä¸ºå¬å”¤çš„å°æ€ªéšæœºåˆ†é…å°å‹ç²¾çµ
                    const smallEnemyVariants = ['enemy1', 'enemy2', 'enemy3', 'enemy4'];
                    const randomVariant = smallEnemyVariants[Math.floor(Math.random() * smallEnemyVariants.length)];

                    const summonedEnemy = {
                        x: enemy.x + Math.cos(angle) * distance,
                        y: enemy.y + Math.sin(angle) * distance,
                        radius: 10,
                        hp: 20,
                        maxHp: 20,
                        damage: 3,
                        speed: 1.5,
                        color: '#ffaa00',
                        goldReward: 5,
                        expReward: 5,
                        type: 'summoned',
                        angle: 0,
                        // æ·»åŠ ç²¾çµå˜ä½“
                        enemyVariant: randomVariant
                    };

                    this.enemies.push(summonedEnemy);
                }

                this.createFloatingText(enemy.x, enemy.y - 30, 'å¬å”¤!', '#ffaa00');
                this.createParticle(enemy.x, enemy.y, '#ffaa00', 20);
            }

            enemyRage(enemy, currentTime) {
                // ç‹‚æš´çŠ¶æ€
                enemy.isRaging = true;
                enemy.rageEndTime = currentTime + 5000; // æŒç»­5ç§’
                enemy.damage *= 1.5; // ä¼¤å®³å¢åŠ 50%

                this.createFloatingText(enemy.x, enemy.y - 30, 'ç‹‚æš´!', '#ff0000');
                this.createParticle(enemy.x, enemy.y, '#ff0000', 25);
            }

            enemyLaser(enemy) {
                // æ¿€å…‰æ”»å‡» - å‘ç©å®¶å‘å°„æ¿€å…‰
                const dx = this.player.x - enemy.x;
                const dy = this.player.y - enemy.y;
                const dist = Math.hypot(dx, dy);

                if (dist > 0) {
                    // åˆ›å»ºæ¿€å…‰æŠ•å°„ç‰©
                    const laser = {
                        x: enemy.x,
                        y: enemy.y,
                        vx: (dx / dist) * 12, // æ¿€å…‰é€Ÿåº¦å¾ˆå¿«
                        vy: (dy / dist) * 12,
                        radius: 8,
                        damage: enemy.damage * 2, // æ¿€å…‰ä¼¤å®³æ˜¯æ™®é€šæ”»å‡»çš„2å€
                        color: '#00ffff',
                        piercing: 0,
                        isLaser: true
                    };

                    this.projectiles.push(laser);
                    this.createFloatingText(enemy.x, enemy.y - 30, 'æ¿€å…‰!', '#00ffff');
                    this.createParticle(enemy.x, enemy.y, '#00ffff', 15);
                }
            }

            enemyTeleport(enemy, currentTime) {
                // ä¼ é€åˆ°ç©å®¶é™„è¿‘çš„éšæœºä½ç½®
                const angle = Math.random() * Math.PI * 2;
                const distance = 80 + Math.random() * 40; // è·ç¦»ç©å®¶80-120åƒç´ 

                enemy.x = this.player.x + Math.cos(angle) * distance;
                enemy.y = this.player.y + Math.sin(angle) * distance;

                // ç¡®ä¿ä¸ä¼ é€åˆ°ç”»å¸ƒå¤–
                enemy.x = Math.max(enemy.radius, Math.min(this.canvas.width - enemy.radius, enemy.x));
                enemy.y = Math.max(enemy.radius, Math.min(this.canvas.height - enemy.radius, enemy.y));

                enemy.lastTeleportTime = currentTime;

                this.createFloatingText(enemy.x, enemy.y - 30, 'ä¼ é€!', '#ff00ff');
                this.createParticle(enemy.x, enemy.y, '#ff00ff', 20);
            }

            enemyShield(enemy, currentTime) {
                // æŠ¤ç›¾æŠ€èƒ½ - å¸æ”¶ä¼¤å®³
                enemy.hasShield = true;
                enemy.shieldEndTime = currentTime + 8000; // æŠ¤ç›¾æŒç»­8ç§’
                enemy.shieldHp = enemy.maxHp * 0.3; // æŠ¤ç›¾è¡€é‡ä¸ºæœ€å¤§è¡€é‡çš„30%
                enemy.color = '#00ff00'; // æŠ¤ç›¾çŠ¶æ€ä¸‹å˜ç»¿è‰²

                this.createFloatingText(enemy.x, enemy.y - 30, 'æŠ¤ç›¾!', '#00ff00');
                this.createParticle(enemy.x, enemy.y, '#00ff00', 30);
            }

            enemyEarthquake(enemy, currentTime) {
                // åœ°éœ‡æŠ€èƒ½ - èŒƒå›´ä¼¤å®³
                enemy.earthquakeCharging = true;
                enemy.earthquakeStartTime = currentTime;

                this.createFloatingText(enemy.x, enemy.y - 30, 'è“„åŠ›ä¸­...', '#ffaa00');

                // 2ç§’åé‡Šæ”¾åœ°éœ‡
                setTimeout(() => {
                    if (enemy.earthquakeCharging) {
                        const playerDist = Math.hypot(enemy.x - this.player.x, enemy.y - this.player.y);
                        if (playerDist < 150) { // åœ°éœ‡èŒƒå›´150åƒç´ 
                            this.damagePlayer(enemy.damage * 1.5);
                            this.createFloatingText(this.player.x, this.player.y - 30, 'åœ°éœ‡ä¼¤å®³!', '#ff0000');
                        }

                        // åœ°éœ‡ç‰¹æ•ˆ
                        for (let i = 0; i < 20; i++) {
                            const angle = (Math.PI * 2 / 20) * i;
                            const x = enemy.x + Math.cos(angle) * 100;
                            const y = enemy.y + Math.sin(angle) * 100;
                            this.createParticle(x, y, '#8b4513', 8);
                        }

                        this.createFloatingText(enemy.x, enemy.y - 30, 'åœ°éœ‡!', '#8b4513');
                        enemy.earthquakeCharging = false;
                    }
                }, 2000);
            }

            damageEnemy(enemy, index, damage) {
                let actualDamage = damage;

                // æ£€æŸ¥æŠ¤ç›¾
                if (enemy.hasShield && enemy.shieldHp > 0) {
                    if (enemy.shieldHp >= damage) {
                        enemy.shieldHp -= damage;
                        actualDamage = 0;
                        this.createFloatingText(enemy.x, enemy.y - enemy.radius, `æŠ¤ç›¾-${damage}`, '#00ff00');
                    } else {
                        actualDamage = damage - enemy.shieldHp;
                        this.createFloatingText(enemy.x, enemy.y - enemy.radius, `æŠ¤ç›¾-${enemy.shieldHp}`, '#00ff00');
                        enemy.shieldHp = 0;
                        enemy.hasShield = false;
                        enemy.color = '#ff0000'; // æ¢å¤åŸè‰²
                    }
                }

                if (actualDamage > 0) {
                    enemy.hp -= actualDamage;
                    this.createFloatingText(enemy.x, enemy.y - enemy.radius, `-${actualDamage}`, '#ffff00');
                }

                if (enemy.hp <= 0) {
                    // æ­»äº¡æ•ˆæœ
                    this.createParticle(enemy.x, enemy.y, enemy.color, 10);

                    // å¥–åŠ±
                    this.kills++;
                    this.gold += enemy.goldReward;
                    this.addExp(enemy.expReward);

                    // æ˜¾ç¤ºå¥–åŠ±
                    this.createFloatingText(enemy.x, enemy.y, `+${enemy.goldReward}G`, '#ffff00');

                    this.enemies.splice(index, 1);
                }
            }
            
            damagePlayer(damage) {
                this.player.hp -= damage;
                
                // æ˜¾ç¤ºä¼¤å®³
                this.createFloatingText(this.player.x, this.player.y - 30, `-${damage}`, '#ff0000');
                
                if (this.player.hp <= 0) {
                    this.gameOver();
                }
            }
            
            addExp(amount) {
                this.exp += amount;
                
                while (this.exp >= this.expNeeded) {
                    this.exp -= this.expNeeded;
                    this.level++;
                    this.expNeeded = Math.floor(this.expNeeded * 1.2);
                    
                    // å‡çº§å¥–åŠ±
                    this.player.maxHp += 20;
                    this.player.hp = this.player.maxHp;
                    this.player.damage += 5;
                    this.player.attackSpeed += 0.1;
                    
                    // å‡çº§ç‰¹æ•ˆ
                    this.createParticle(this.player.x, this.player.y, '#00ff00', 20);
                    this.createFloatingText(this.player.x, this.player.y - 50, 'LEVEL UP!', '#00ff00');
                }
            }
            
            upgradePlayer(stat) {
                const cost = this.upgradeCosts[stat];
                const currentLevel = this.upgradeLevels[stat];
                const maxLevel = this.upgradeMaxLevels[stat];

                // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°å‡çº§ä¸Šé™
                if (currentLevel >= maxLevel) {
                    return;
                }

                if (this.gold >= cost) {
                    this.gold -= cost;
                    this.upgradeLevels[stat]++;

                    switch(stat) {
                        case 'damage':
                            this.player.damage += 10;
                            this.upgradeCosts.damage = Math.floor(this.upgradeCosts.damage * 1.3);
                            break;
                        case 'attackSpeed':
                            this.player.attackSpeed += 0.5;
                            this.upgradeCosts.attackSpeed = Math.floor(this.upgradeCosts.attackSpeed * 1.3);
                            break;
                        case 'maxHp':
                            this.player.maxHp += 50;
                            this.player.hp += 50;
                            this.upgradeCosts.maxHp = Math.floor(this.upgradeCosts.maxHp * 1.3);
                            break;
                        case 'range':
                            this.player.range += 20;
                            this.upgradeCosts.range = Math.floor(this.upgradeCosts.range * 1.3);
                            break;
                        case 'regen':
                            this.player.regen += 1;
                            this.upgradeCosts.regen = Math.floor(this.upgradeCosts.regen * 1.3);
                            break;
                        case 'bulletCount':
                            this.player.bulletCount += 1;
                            this.upgradeCosts.bulletCount = Math.floor(this.upgradeCosts.bulletCount * 1.5);
                            break;
                        case 'maxAmmo':
                            this.player.maxAmmo += 10;
                            this.player.ammo += 10;
                            this.upgradeCosts.maxAmmo = Math.floor(this.upgradeCosts.maxAmmo * 1.3);
                            break;
                        case 'reloadSpeed':
                            this.player.reloadSpeed = Math.floor(this.player.reloadSpeed * 0.8);
                            this.upgradeCosts.reloadSpeed = Math.floor(this.upgradeCosts.reloadSpeed * 1.4);
                            break;
                    }

                    this.updateUpgradeButtons();
                    this.updateUI();
                }
            }
            
            showUpgradeMenu() {
                document.getElementById('upgradeMenu').style.display = 'block';
                document.getElementById('upgradeBtn').classList.add('active');
                this.updateUpgradeButtons();
            }
            
            hideUpgradeMenu() {
                document.getElementById('upgradeMenu').style.display = 'none';
                document.getElementById('upgradeBtn').classList.remove('active');
            }
            
            updateUpgradeButtons() {
                // æ›´æ–°æŒ‰é’®æ–‡æœ¬ï¼Œæ˜¾ç¤ºç­‰çº§ä¿¡æ¯
                const damageMaxText = this.upgradeMaxLevels.damage === 999 ? 'âˆ' : this.upgradeMaxLevels.damage;
                const hpMaxText = this.upgradeMaxLevels.maxHp === 999 ? 'âˆ' : this.upgradeMaxLevels.maxHp;
                const regenMaxText = this.upgradeMaxLevels.regen === 999 ? 'âˆ' : this.upgradeMaxLevels.regen;
                const ammoMaxText = this.upgradeMaxLevels.maxAmmo === 999 ? 'âˆ' : this.upgradeMaxLevels.maxAmmo;

                document.getElementById('upgradeDamage').textContent = `æ”»å‡»åŠ› +10 [${this.upgradeLevels.damage}/${damageMaxText}] (${this.upgradeCosts.damage}é‡‘å¸)`;
                document.getElementById('upgradeSpeed').textContent = `æ”»é€Ÿ +0.5 [${this.upgradeLevels.attackSpeed}/${this.upgradeMaxLevels.attackSpeed}] (${this.upgradeCosts.attackSpeed}é‡‘å¸)`;
                document.getElementById('upgradeHp').textContent = `ç”Ÿå‘½å€¼ +50 [${this.upgradeLevels.maxHp}/${hpMaxText}] (${this.upgradeCosts.maxHp}é‡‘å¸)`;
                document.getElementById('upgradeRange').textContent = `å°„ç¨‹ +20 [${this.upgradeLevels.range}/${this.upgradeMaxLevels.range}] (${this.upgradeCosts.range}é‡‘å¸)`;
                document.getElementById('upgradeRegen').textContent = `ç”Ÿå‘½å›å¤ +1 [${this.upgradeLevels.regen}/${regenMaxText}] (${this.upgradeCosts.regen}é‡‘å¸)`;
                document.getElementById('upgradeBullets').textContent = `å­å¼¹æ•°é‡ +1 [${this.upgradeLevels.bulletCount}/${this.upgradeMaxLevels.bulletCount}] (${this.upgradeCosts.bulletCount}é‡‘å¸)`;
                document.getElementById('upgradeAmmo').textContent = `å¼¹åŒ£å®¹é‡ +10 [${this.upgradeLevels.maxAmmo}/${ammoMaxText}] (${this.upgradeCosts.maxAmmo}é‡‘å¸)`;
                document.getElementById('upgradeReload').textContent = `æ¢å¼¹é€Ÿåº¦ +20% [${this.upgradeLevels.reloadSpeed}/${this.upgradeMaxLevels.reloadSpeed}] (${this.upgradeCosts.reloadSpeed}é‡‘å¸)`;

                // æ›´æ–°æŒ‰é’®çŠ¶æ€ - æ£€æŸ¥é‡‘å¸å’Œç­‰çº§ä¸Šé™
                document.getElementById('upgradeDamage').disabled = this.gold < this.upgradeCosts.damage || this.upgradeLevels.damage >= this.upgradeMaxLevels.damage;
                document.getElementById('upgradeSpeed').disabled = this.gold < this.upgradeCosts.attackSpeed || this.upgradeLevels.attackSpeed >= this.upgradeMaxLevels.attackSpeed;
                document.getElementById('upgradeHp').disabled = this.gold < this.upgradeCosts.maxHp || this.upgradeLevels.maxHp >= this.upgradeMaxLevels.maxHp;
                document.getElementById('upgradeRange').disabled = this.gold < this.upgradeCosts.range || this.upgradeLevels.range >= this.upgradeMaxLevels.range;
                document.getElementById('upgradeRegen').disabled = this.gold < this.upgradeCosts.regen || this.upgradeLevels.regen >= this.upgradeMaxLevels.regen;
                document.getElementById('upgradeBullets').disabled = this.gold < this.upgradeCosts.bulletCount || this.upgradeLevels.bulletCount >= this.upgradeMaxLevels.bulletCount;
                document.getElementById('upgradeAmmo').disabled = this.gold < this.upgradeCosts.maxAmmo || this.upgradeLevels.maxAmmo >= this.upgradeMaxLevels.maxAmmo;
                document.getElementById('upgradeReload').disabled = this.gold < this.upgradeCosts.reloadSpeed || this.upgradeLevels.reloadSpeed >= this.upgradeMaxLevels.reloadSpeed;

                // ä¸ºè¾¾åˆ°ä¸Šé™çš„æŒ‰é’®æ·»åŠ ç‰¹æ®Šæ ·å¼
                const buttons = ['upgradeDamage', 'upgradeSpeed', 'upgradeHp', 'upgradeRange', 'upgradeRegen', 'upgradeBullets', 'upgradeAmmo', 'upgradeReload'];
                const stats = ['damage', 'attackSpeed', 'maxHp', 'range', 'regen', 'bulletCount', 'maxAmmo', 'reloadSpeed'];

                buttons.forEach((buttonId, index) => {
                    const button = document.getElementById(buttonId);
                    const stat = stats[index];
                    if (this.upgradeLevels[stat] >= this.upgradeMaxLevels[stat]) {
                        button.style.backgroundColor = '#666';
                        button.style.color = '#999';
                        button.textContent = button.textContent.replace(/\(.*?\)/, '(å·²æ»¡çº§)');
                    } else {
                        button.style.backgroundColor = '';
                        button.style.color = '';
                    }
                });
            }
            
            updateUI() {
                document.getElementById('wave').textContent = this.wave;
                document.getElementById('kills').textContent = this.kills;
                document.getElementById('gold').textContent = this.gold;
                document.getElementById('exp').textContent = this.exp;
                document.getElementById('expNeeded').textContent = this.expNeeded;
                document.getElementById('level').textContent = this.level;

                // æ˜¾ç¤ºå½“å‰åœ°å›¾ä¿¡æ¯
                const mapNames = {
                    'bg1': 'ğŸŒ² æ£®æ—æˆ˜åœº',
                    'bg2': 'ğŸœï¸ æ²™æ¼ æˆ˜åœº'
                };
                document.getElementById('currentMap').textContent = mapNames[this.currentBackground] || this.currentBackground;
                document.getElementById('hp').textContent = Math.max(0, Math.floor(this.player.hp));
                document.getElementById('maxHp').textContent = this.player.maxHp;
                document.getElementById('damage').textContent = this.player.damage;
                document.getElementById('attackSpeed').textContent = this.player.attackSpeed.toFixed(1);
                document.getElementById('range').textContent = Math.floor(this.player.range);
                document.getElementById('regen').textContent = this.player.regen;
                document.getElementById('bulletCount').textContent = this.player.bulletCount;
                document.getElementById('ammo').textContent = this.player.ammo;
                document.getElementById('maxAmmo').textContent = this.player.maxAmmo;
                
                // æ›´æ–°å¼¹è¯æ¡
                const ammoPercent = this.player.ammo / this.player.maxAmmo;
                document.getElementById('ammoBar').style.width = `${ammoPercent * 100}%`;
            }
            
            gameOver() {
                this.isPaused = true;
                document.getElementById('finalDifficulty').textContent = this.difficultySettings[this.difficulty].name;
                document.getElementById('finalWave').textContent = this.wave;
                document.getElementById('finalKills').textContent = this.kills;
                document.getElementById('finalLevel').textContent = this.level;
                document.getElementById('gameOver').style.display = 'block';
            }
            
            render() {
                // ç»˜åˆ¶èƒŒæ™¯
                this.drawBackground();

                if (!this.isGameStarted) return;

                // ç»˜åˆ¶ç½‘æ ¼
                this.drawGrid();
                
                // ç»˜åˆ¶æ”»å‡»èŒƒå›´
                this.ctx.strokeStyle = 'rgba(0, 255, 0, 0.2)';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.arc(this.player.x, this.player.y, this.player.range, 0, Math.PI * 2);
                this.ctx.stroke();
                
                // ç»˜åˆ¶ç©å®¶
                this.drawPlayer();
                
                // ç»˜åˆ¶ç©å®¶è¡€æ¡ï¼ˆæ ¹æ®åŠ¨æ€å¤§å°è°ƒæ•´ä½ç½®ï¼‰
                const playerSize = this.getPlayerSize();
                const playerRadius = playerSize / 2;
                const hpBarY = this.player.y - playerRadius - 15; // è¡€æ¡åœ¨äººç‰©ä¸Šæ–¹15åƒç´ 
                const hpPercent = this.player.hp / this.player.maxHp;

                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(this.player.x - 25, hpBarY, 50, 5);
                this.ctx.fillStyle = hpPercent > 0.5 ? '#0f0' : hpPercent > 0.25 ? '#ff0' : '#f00';
                this.ctx.fillRect(this.player.x - 25, hpBarY, 50 * hpPercent, 5);
                
                // ç»˜åˆ¶æ¢å¼¹è¿›åº¦ï¼ˆæ ¹æ®åŠ¨æ€å¤§å°è°ƒæ•´ä½ç½®ï¼‰
                if (this.player.isReloading) {
                    const reloadBarY = this.player.y + playerRadius + 10; // æ¢å¼¹æ¡åœ¨äººç‰©ä¸‹æ–¹10åƒç´ 
                    const reloadProgress = (Date.now() - this.player.reloadStartTime) / this.player.reloadSpeed;
                    this.ctx.fillStyle = '#000';
                    this.ctx.fillRect(this.player.x - 25, reloadBarY, 50, 3);
                    this.ctx.fillStyle = '#00ffff';
                    this.ctx.fillRect(this.player.x - 25, reloadBarY, 50 * reloadProgress, 3);
                }
                
                // ç»˜åˆ¶æ•Œäºº
                for (const enemy of this.enemies) {
                    // æ•Œäººèº«ä½“
                    this.ctx.fillStyle = enemy.color;
                    this.ctx.beginPath();
                    
                    if (enemy.type === 'boss') {
                        // Bossç”¨ä¸“é—¨çš„bossç²¾çµå›¾ç‰‡
                        this.drawBoss(enemy);
                    } else {
                        // æ‰€æœ‰å…¶ä»–æ•Œäººéƒ½ç”¨ç²¾çµå›¾ç‰‡
                        this.drawEnemy(enemy);
                    }
                    
                    // æ•Œäººè¡€æ¡
                    const enemyHpPercent = enemy.hp / enemy.maxHp;
                    this.ctx.fillStyle = '#000';
                    this.ctx.fillRect(enemy.x - enemy.radius, enemy.y - enemy.radius - 10, enemy.radius * 2, 4);
                    this.ctx.fillStyle = enemyHpPercent > 0.5 ? '#0f0' : enemyHpPercent > 0.25 ? '#ff0' : '#f00';
                    this.ctx.fillRect(enemy.x - enemy.radius, enemy.y - enemy.radius - 10, enemy.radius * 2 * enemyHpPercent, 4);
                }
                
                // ç»˜åˆ¶æŠ•å°„ç‰©
                for (const proj of this.projectiles) {
                    this.drawBullet(proj);
                }
                
                // ç»˜åˆ¶ç²’å­
                for (const particle of this.particles) {
                    this.ctx.fillStyle = particle.color;
                    this.ctx.globalAlpha = particle.life;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                this.ctx.globalAlpha = 1;
                
                // ç»˜åˆ¶æµ®åŠ¨æ–‡å­—
                for (const text of this.floatingTexts) {
                    this.ctx.fillStyle = text.color;
                    this.ctx.globalAlpha = text.life;
                    this.ctx.font = 'bold 16px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(text.text, text.x, text.y);
                }
                this.ctx.globalAlpha = 1;
            }
            
            drawGrid() {
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                this.ctx.lineWidth = 1;
                
                const gridSize = 50;
                
                for (let x = 0; x < this.canvas.width; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                
                for (let y = 0; y < this.canvas.height; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
            }
            
            drawPolygon(x, y, radius, sides) {
                this.ctx.beginPath();
                for (let i = 0; i < sides; i++) {
                    const angle = (i / sides) * Math.PI * 2 - Math.PI / 2;
                    const px = x + Math.cos(angle) * radius;
                    const py = y + Math.sin(angle) * radius;
                    if (i === 0) {
                        this.ctx.moveTo(px, py);
                    } else {
                        this.ctx.lineTo(px, py);
                    }
                }
                this.ctx.closePath();
            }
            
            drawStar(x, y, outerRadius, innerRadius, points) {
                this.ctx.beginPath();
                for (let i = 0; i < points * 2; i++) {
                    const angle = (i / (points * 2)) * Math.PI * 2 - Math.PI / 2;
                    const radius = i % 2 === 0 ? outerRadius : innerRadius;
                    const px = x + Math.cos(angle) * radius;
                    const py = y + Math.sin(angle) * radius;
                    if (i === 0) {
                        this.ctx.moveTo(px, py);
                    } else {
                        this.ctx.lineTo(px, py);
                    }
                }
                this.ctx.closePath();
                this.ctx.fill();
            }

            // åˆ¤æ–­ç©å®¶æ˜¯å¦è¾¾åˆ°æ»¡çº§çŠ¶æ€
            isPlayerMaxLevel() {
                // æ£€æŸ¥æ”»é€Ÿã€å­å¼¹æ•°é‡ã€å°„ç¨‹ã€æ¢å¼¹é€Ÿåº¦æ˜¯å¦éƒ½è¾¾åˆ°æ»¡çº§
                return this.upgradeLevels.attackSpeed >= this.upgradeMaxLevels.attackSpeed &&
                       this.upgradeLevels.bulletCount >= this.upgradeMaxLevels.bulletCount &&
                       this.upgradeLevels.range >= this.upgradeMaxLevels.range &&
                       this.upgradeLevels.reloadSpeed >= this.upgradeMaxLevels.reloadSpeed;
            }

            // æ£€æŸ¥å¹¶è§¦å‘äººç‰©å½¢è±¡å˜åŒ–ç‰¹æ•ˆ
            checkPlayerTransformation() {
                const newForm = this.isPlayerMaxLevel() ? 'player1' : 'player';

                // å¦‚æœå½¢è±¡å‘ç”Ÿå˜åŒ–ï¼Œè§¦å‘ç‰¹æ•ˆ
                if (newForm !== this.currentPlayerForm) {
                    this.currentPlayerForm = newForm;
                    this.triggerTransformEffect();
                }
            }

            // è§¦å‘å˜èº«ç‰¹æ•ˆ
            triggerTransformEffect() {
                this.transformEffect.active = true;
                this.transformEffect.startTime = Date.now();
                this.transformEffect.particles = [];

                // åˆ›å»ºå˜èº«ç²’å­ç‰¹æ•ˆ
                for (let i = 0; i < 30; i++) {
                    const angle = (Math.PI * 2 / 30) * i;
                    const speed = 3 + Math.random() * 4;
                    const distance = 20 + Math.random() * 30;

                    this.transformEffect.particles.push({
                        x: this.player.x + Math.cos(angle) * distance,
                        y: this.player.y + Math.sin(angle) * distance,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 1.0,
                        decay: 0.015,
                        color: this.currentPlayerForm === 'player1' ? '#ffff00' : '#00ffff',
                        size: 3 + Math.random() * 3
                    });
                }

                // æ˜¾ç¤ºå˜èº«æç¤º
                const message = this.currentPlayerForm === 'player1' ? 'âœ¨ ç»ˆæå½¢æ€ï¼âœ¨' : 'âš¡ åŸºç¡€å½¢æ€ âš¡';
                this.createFloatingText(this.player.x, this.player.y - 60, message, '#ffff00');

                // åˆ›å»ºå†²å‡»æ³¢æ•ˆæœ
                this.createShockwave();
            }

            // åˆ›å»ºå†²å‡»æ³¢æ•ˆæœ
            createShockwave() {
                this.transformEffect.shockwave = {
                    x: this.player.x,
                    y: this.player.y,
                    radius: 0,
                    maxRadius: 100,
                    alpha: 0.8,
                    startTime: Date.now()
                };
            }

            // è®¡ç®—ç©å®¶çš„åŠ¨æ€å¤§å°
            getPlayerSize() {
                // åŸºç¡€å¤§å°
                const baseSize = 40; // åŸºç¡€ç›´å¾„

                // æ ¹æ®å„ç§å±æ€§è®¡ç®—å¤§å°å¢ç›Š
                const attackSpeedBonus = this.upgradeLevels.attackSpeed * 0.8; // æ”»é€Ÿæ¯çº§å¢åŠ 0.8åƒç´ 
                const bulletCountBonus = this.upgradeLevels.bulletCount * 8; // å­å¼¹æ•°é‡æ¯çº§å¢åŠ 8åƒç´ 
                const rangeBonus = this.upgradeLevels.range * 1.2; // å°„ç¨‹æ¯çº§å¢åŠ 1.2åƒç´ 
                const reloadSpeedBonus = this.upgradeLevels.reloadSpeed * 1.5; // æ¢å¼¹é€Ÿåº¦æ¯çº§å¢åŠ 1.5åƒç´ 
                const levelBonus = (this.level - 1) * 0.5; // ç­‰çº§æ¯çº§å¢åŠ 0.5åƒç´ 

                // è®¡ç®—æ€»å¤§å°
                const totalSize = baseSize + attackSpeedBonus + bulletCountBonus + rangeBonus + reloadSpeedBonus + levelBonus;

                // é™åˆ¶æœ€å¤§å¤§å°ï¼Œé¿å…è¿‡å¤§
                return Math.min(totalSize, 80);
            }

            // è®¡ç®—bossçš„åŠ¨æ€å¤§å°
            getBossSize(enemy) {
                // bossåŸºç¡€å¤§å°æ¯”ç©å®¶å¤§
                let baseSize = enemy.radius * 2; // ä½¿ç”¨bossçš„åŸºç¡€åŠå¾„

                // æ ¹æ®æ³¢æ¬¡å¢åŠ å¤§å°
                const waveBonus = (this.wave - 1) * 1.5; // æ¯æ³¢å¢åŠ 1.5åƒç´ 

                // æ ¹æ®bossç±»å‹è°ƒæ•´å¤§å°
                let typeMultiplier = 1;
                if (enemy.bossVariant === 'bigboss') {
                    typeMultiplier = 1.8; // å¤§bossæ›´å¤§
                } else if (enemy.bossVariant && enemy.bossVariant.startsWith('xiaoboss')) {
                    typeMultiplier = 1.4; // å°bossç³»åˆ—ä¸­ç­‰å¤§å°
                } else if (enemy.bossVariant && enemy.bossVariant.startsWith('boss')) {
                    typeMultiplier = 1.2; // æ™®é€šbossç³»åˆ—ç¨å¤§
                }

                // åˆ†è£‚bossåº”è¯¥æ¯”åŸbosså°
                if (enemy.type === 'split') {
                    typeMultiplier *= 0.7;
                }

                // è®¡ç®—æœ€ç»ˆå¤§å°
                const finalSize = (baseSize + waveBonus) * typeMultiplier;

                // é™åˆ¶æœ€å¤§å¤§å°
                return Math.min(finalSize, 150);
            }

            // ç»˜åˆ¶èƒŒæ™¯åœ°å›¾
            drawBackground() {
                // å…ˆç”¨çº¯è‰²å¡«å……ä½œä¸ºåå¤‡
                this.ctx.fillStyle = '#1a1a1a';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // å¦‚æœèƒŒæ™¯å›¾ç‰‡å·²åŠ è½½ï¼Œåˆ™ç»˜åˆ¶èƒŒæ™¯
                if (this.backgroundsLoaded[this.currentBackground]) {
                    const bgImage = this.backgroundImages[this.currentBackground];

                    // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹ä»¥å¡«æ»¡æ•´ä¸ªç”»å¸ƒ
                    const scaleX = this.canvas.width / bgImage.width;
                    const scaleY = this.canvas.height / bgImage.height;
                    const scale = Math.max(scaleX, scaleY); // ä½¿ç”¨è¾ƒå¤§çš„ç¼©æ”¾æ¯”ä¾‹ç¡®ä¿å¡«æ»¡

                    const scaledWidth = bgImage.width * scale;
                    const scaledHeight = bgImage.height * scale;

                    // å±…ä¸­ç»˜åˆ¶
                    const x = (this.canvas.width - scaledWidth) / 2;
                    const y = (this.canvas.height - scaledHeight) / 2;

                    this.ctx.drawImage(bgImage, x, y, scaledWidth, scaledHeight);

                    // æ·»åŠ è½»å¾®çš„æš—åŒ–æ•ˆæœï¼Œè®©æ¸¸æˆå…ƒç´ æ›´çªå‡º
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                }
            }

            // ç»˜åˆ¶ç©å®¶ç²¾çµ
            drawPlayer() {
                // æ£€æŸ¥æ˜¯å¦éœ€è¦è§¦å‘å˜èº«ç‰¹æ•ˆ
                this.checkPlayerTransformation();

                if (this.spriteLoaded) {
                    // æ ¹æ®å‡çº§çŠ¶æ€é€‰æ‹©ç²¾çµ
                    const spriteKey = this.currentPlayerForm;
                    const sprite = this.sprites[spriteKey];

                    // è·å–åŠ¨æ€å¤§å°
                    const playerSize = this.getPlayerSize();

                    // è®¡ç®—ç»˜åˆ¶å°ºå¯¸ï¼ˆä¿æŒæ¯”ä¾‹ï¼Œä½¿ç”¨åŠ¨æ€å¤§å°ï¼‰
                    const scale = playerSize / Math.max(sprite.width, sprite.height);
                    const drawWidth = sprite.width * scale;
                    const drawHeight = sprite.height * scale;

                    // å˜èº«ç‰¹æ•ˆæœŸé—´çš„é—ªçƒæ•ˆæœ
                    let alpha = 1;
                    if (this.transformEffect.active) {
                        const elapsed = Date.now() - this.transformEffect.startTime;
                        const progress = elapsed / this.transformEffect.duration;

                        if (progress < 1) {
                            // é—ªçƒæ•ˆæœ
                            alpha = 0.5 + 0.5 * Math.sin(elapsed * 0.02);
                        } else {
                            this.transformEffect.active = false;
                        }
                    }

                    // å¦‚æœæ­£åœ¨æ¢å¼¹ï¼Œæ·»åŠ ç°è‰²æ»¤é•œæ•ˆæœ
                    if (this.player.isReloading) {
                        this.ctx.globalAlpha = 0.6 * alpha;
                        this.ctx.filter = 'grayscale(100%)';
                    } else {
                        this.ctx.globalAlpha = alpha;
                    }

                    // ç»˜åˆ¶ç²¾çµ
                    this.ctx.drawImage(
                        this.playerSprite,
                        sprite.x, sprite.y, sprite.width, sprite.height,
                        this.player.x - drawWidth / 2, this.player.y - drawHeight / 2,
                        drawWidth, drawHeight
                    );

                    // é‡ç½®æ»¤é•œå’Œé€æ˜åº¦
                    this.ctx.globalAlpha = 1;
                    this.ctx.filter = 'none';
                } else {
                    // å¦‚æœç²¾çµæœªåŠ è½½ï¼Œä½¿ç”¨åŸæ¥çš„åœ†å½¢ç»˜åˆ¶ï¼ˆä¹Ÿä½¿ç”¨åŠ¨æ€å¤§å°ï¼‰
                    const playerSize = this.getPlayerSize();
                    const radius = playerSize / 2;

                    this.ctx.fillStyle = this.player.isReloading ? '#888888' : this.player.color;
                    this.ctx.beginPath();
                    this.ctx.arc(this.player.x, this.player.y, radius, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                // ç»˜åˆ¶å˜èº«ç‰¹æ•ˆ
                this.drawTransformEffect();
            }

            // ç»˜åˆ¶å˜èº«ç‰¹æ•ˆ
            drawTransformEffect() {
                if (!this.transformEffect.active) return;

                const currentTime = Date.now();
                const elapsed = currentTime - this.transformEffect.startTime;
                const progress = elapsed / this.transformEffect.duration;

                if (progress >= 1) {
                    this.transformEffect.active = false;
                    return;
                }

                // ç»˜åˆ¶å†²å‡»æ³¢
                if (this.transformEffect.shockwave) {
                    const shockwave = this.transformEffect.shockwave;
                    const shockwaveProgress = elapsed / 1000; // å†²å‡»æ³¢1ç§’å†…å®Œæˆ

                    if (shockwaveProgress < 1) {
                        shockwave.radius = shockwave.maxRadius * shockwaveProgress;
                        shockwave.alpha = 0.8 * (1 - shockwaveProgress);

                        this.ctx.strokeStyle = `rgba(255, 255, 0, ${shockwave.alpha})`;
                        this.ctx.lineWidth = 3;
                        this.ctx.beginPath();
                        this.ctx.arc(shockwave.x, shockwave.y, shockwave.radius, 0, Math.PI * 2);
                        this.ctx.stroke();

                        // å†…åœˆå†²å‡»æ³¢
                        this.ctx.strokeStyle = `rgba(255, 255, 255, ${shockwave.alpha * 0.5})`;
                        this.ctx.lineWidth = 1;
                        this.ctx.beginPath();
                        this.ctx.arc(shockwave.x, shockwave.y, shockwave.radius * 0.7, 0, Math.PI * 2);
                        this.ctx.stroke();
                    }
                }

                // æ›´æ–°å’Œç»˜åˆ¶å˜èº«ç²’å­
                for (let i = this.transformEffect.particles.length - 1; i >= 0; i--) {
                    const particle = this.transformEffect.particles[i];

                    // æ›´æ–°ç²’å­ä½ç½®
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.life -= particle.decay;

                    // ç§»é™¤ç”Ÿå‘½å€¼è€—å°½çš„ç²’å­
                    if (particle.life <= 0) {
                        this.transformEffect.particles.splice(i, 1);
                        continue;
                    }

                    // ç»˜åˆ¶ç²’å­
                    this.ctx.fillStyle = particle.color;
                    this.ctx.globalAlpha = particle.life;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();

                    // æ·»åŠ ç²’å­å…‰æ™•æ•ˆæœ
                    this.ctx.shadowColor = particle.color;
                    this.ctx.shadowBlur = 10;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size * 0.5, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0;
                }

                this.ctx.globalAlpha = 1;
            }

            // ç»˜åˆ¶bossç²¾çµ
            drawBoss(enemy) {
                if (!enemy.bossVariant) {
                    // å¦‚æœæ²¡æœ‰å˜ä½“ä¿¡æ¯ï¼Œä½¿ç”¨é»˜è®¤æ˜Ÿå½¢
                    this.drawStar(enemy.x, enemy.y, enemy.radius, enemy.radius * 0.5, 8);
                    return;
                }

                const variant = enemy.bossVariant;
                let spriteImage = null;
                let spriteData = null;

                // ç¡®å®šä½¿ç”¨å“ªä¸ªå›¾ç‰‡å’Œç²¾çµæ•°æ®
                if (variant === 'bigboss') {
                    spriteImage = this.bossSprites.bigboss;
                    spriteData = this.sprites.bigboss;
                } else if (variant === 'xiaoboss') {
                    spriteImage = this.bossSprites.xiaoboss;
                    spriteData = this.sprites.xiaoboss;
                } else if (variant === 'xiaoboss1') {
                    spriteImage = this.bossSprites.xiaoboss1;
                    spriteData = this.sprites.xiaoboss1;
                } else if (variant.startsWith('xiaoboss2_')) {
                    spriteImage = this.bossSprites.xiaoboss2;
                    spriteData = this.sprites[variant];
                } else if (variant.startsWith('boss')) {
                    spriteImage = this.bossSprites.boss;
                    spriteData = this.sprites[variant];
                }

                // æ£€æŸ¥å›¾ç‰‡æ˜¯å¦åŠ è½½å®Œæˆ
                const spriteKey = variant === 'bigboss' ? 'bigboss' :
                                 variant === 'xiaoboss' ? 'xiaoboss' :
                                 variant === 'xiaoboss1' ? 'xiaoboss1' :
                                 variant.startsWith('xiaoboss2_') ? 'xiaoboss2' : 'boss';

                if (!this.bossSpritesLoaded[spriteKey] || !spriteImage || !spriteData) {
                    // å¦‚æœå›¾ç‰‡æœªåŠ è½½ï¼Œä½¿ç”¨æ˜Ÿå½¢ä½œä¸ºåå¤‡
                    this.drawStar(enemy.x, enemy.y, enemy.radius, enemy.radius * 0.5, 8);
                    return;
                }

                // è®¡ç®—bossçš„åŠ¨æ€å¤§å°ï¼ˆç±»ä¼¼ç©å®¶ç³»ç»Ÿï¼‰
                const bossSize = this.getBossSize(enemy);
                const scale = bossSize / Math.max(spriteData.width, spriteData.height);
                const drawWidth = spriteData.width * scale;
                const drawHeight = spriteData.height * scale;

                // ç‹‚æš´çŠ¶æ€ç‰¹æ•ˆ
                if (enemy.isRaging) {
                    this.ctx.shadowColor = '#ff0000';
                    this.ctx.shadowBlur = 15;
                }

                // æŠ¤ç›¾çŠ¶æ€ç‰¹æ•ˆ
                if (enemy.hasShield) {
                    this.ctx.shadowColor = '#00ff00';
                    this.ctx.shadowBlur = 10;
                }

                // ç»˜åˆ¶bossç²¾çµ
                if (variant === 'bigboss') {
                    // bigbossæ˜¯å•å¼ å›¾ç‰‡ï¼Œç»˜åˆ¶æ•´ä¸ªå›¾ç‰‡
                    this.ctx.drawImage(
                        spriteImage,
                        enemy.x - drawWidth / 2, enemy.y - drawHeight / 2,
                        drawWidth, drawHeight
                    );
                } else {
                    // å…¶ä»–bossä»ç²¾çµè¡¨ä¸­ç»˜åˆ¶
                    this.ctx.drawImage(
                        spriteImage,
                        spriteData.x, spriteData.y, spriteData.width, spriteData.height,
                        enemy.x - drawWidth / 2, enemy.y - drawHeight / 2,
                        drawWidth, drawHeight
                    );
                }

                // é‡ç½®é˜´å½±
                this.ctx.shadowBlur = 0;
            }

            // ç»˜åˆ¶æ•Œäººç²¾çµ
            drawEnemy(enemy) {
                if (!enemy.enemyVariant) {
                    // å¦‚æœæ²¡æœ‰å˜ä½“ä¿¡æ¯ï¼Œä½¿ç”¨åœ†å½¢ä½œä¸ºåå¤‡
                    this.ctx.fillStyle = enemy.color;
                    this.ctx.beginPath();
                    this.ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    return;
                }

                // æ£€æŸ¥æ˜¯å¦ä½¿ç”¨bossç²¾çµï¼ˆç²¾è‹±æ•Œäººï¼‰
                if (enemy.usesBossSprite) {
                    this.drawEnemyWithBossSprite(enemy);
                    return;
                }

                // ä½¿ç”¨æ™®é€šæ•Œäººç²¾çµ
                if (!this.enemySpriteLoaded) {
                    // å¦‚æœå›¾ç‰‡æœªåŠ è½½ï¼Œä½¿ç”¨åœ†å½¢ä½œä¸ºåå¤‡
                    this.ctx.fillStyle = enemy.color;
                    this.ctx.beginPath();
                    this.ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    return;
                }

                const spriteData = this.sprites[enemy.enemyVariant];
                if (!spriteData) {
                    // å¦‚æœç²¾çµæ•°æ®ä¸å­˜åœ¨ï¼Œä½¿ç”¨åœ†å½¢ä½œä¸ºåå¤‡
                    this.ctx.fillStyle = enemy.color;
                    this.ctx.beginPath();
                    this.ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    return;
                }

                // è®¡ç®—ç»˜åˆ¶å°ºå¯¸
                const scale = (enemy.radius * 2) / Math.max(spriteData.width, spriteData.height);
                const drawWidth = spriteData.width * scale;
                const drawHeight = spriteData.height * scale;

                // æ·»åŠ ä¸åŒç±»å‹æ•Œäººçš„ç‰¹æ•ˆ
                this.applyEnemyEffects(enemy);

                // ç»˜åˆ¶æ•Œäººç²¾çµ
                this.ctx.drawImage(
                    this.enemySprite,
                    spriteData.x, spriteData.y, spriteData.width, spriteData.height,
                    enemy.x - drawWidth / 2, enemy.y - drawHeight / 2,
                    drawWidth, drawHeight
                );

                // é‡ç½®é˜´å½±
                this.ctx.shadowBlur = 0;
            }

            // ä¸ºç²¾è‹±æ•Œäººç»˜åˆ¶bossç²¾çµ
            drawEnemyWithBossSprite(enemy) {
                const variant = enemy.enemyVariant;
                const spriteImage = this.bossSprites.boss;
                const spriteData = this.sprites[variant];

                if (!this.bossSpritesLoaded.boss || !spriteData) {
                    // å¦‚æœbosså›¾ç‰‡æœªåŠ è½½ï¼Œä½¿ç”¨åœ†å½¢ä½œä¸ºåå¤‡
                    this.ctx.fillStyle = enemy.color;
                    this.ctx.beginPath();
                    this.ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    return;
                }

                // è®¡ç®—ç»˜åˆ¶å°ºå¯¸ï¼ˆç²¾è‹±æ•Œäººä½¿ç”¨bossç²¾çµä½†ä¿æŒæ•Œäººå¤§å°ï¼‰
                const enemySize = enemy.radius * 2.2; // ç²¾è‹±æ•Œäººç¨å¤§ä¸€äº›
                const scale = enemySize / Math.max(spriteData.width, spriteData.height);
                const drawWidth = spriteData.width * scale;
                const drawHeight = spriteData.height * scale;

                // ç²¾è‹±æ•Œäººç‰¹æ•ˆ
                this.applyEnemyEffects(enemy);

                // ç»˜åˆ¶bossç²¾çµ
                this.ctx.drawImage(
                    spriteImage,
                    spriteData.x, spriteData.y, spriteData.width, spriteData.height,
                    enemy.x - drawWidth / 2, enemy.y - drawHeight / 2,
                    drawWidth, drawHeight
                );

                // é‡ç½®é˜´å½±
                this.ctx.shadowBlur = 0;
            }

            // åº”ç”¨ä¸åŒç±»å‹æ•Œäººçš„è§†è§‰ç‰¹æ•ˆ
            applyEnemyEffects(enemy) {
                switch (enemy.type) {
                    case 'fast':
                        // å¿«é€Ÿæ•Œäººï¼šè“è‰²å…‰æ™•
                        this.ctx.shadowColor = '#00aaff';
                        this.ctx.shadowBlur = 8;
                        break;
                    case 'tank':
                        // å¦å…‹æ•Œäººï¼šçº¢è‰²å…‰æ™•
                        this.ctx.shadowColor = '#ff4444';
                        this.ctx.shadowBlur = 10;
                        break;
                    case 'elite':
                        // ç²¾è‹±æ•Œäººï¼šé‡‘è‰²å…‰æ™•
                        this.ctx.shadowColor = '#ffaa00';
                        this.ctx.shadowBlur = 12;
                        break;
                    case 'split':
                        // åˆ†è£‚æ•Œäººï¼šç´«è‰²å…‰æ™•ï¼Œè¡¨ç¤ºå®ƒä»¬æ¥è‡ªåˆ†è£‚
                        this.ctx.shadowColor = '#ff00ff';
                        this.ctx.shadowBlur = 10;
                        break;
                    case 'summoned':
                        // å¬å”¤æ•Œäººï¼šæ©™è‰²å…‰æ™•ï¼Œè¡¨ç¤ºå®ƒä»¬æ˜¯è¢«å¬å”¤çš„
                        this.ctx.shadowColor = '#ffaa00';
                        this.ctx.shadowBlur = 6;
                        break;
                    default:
                        // æ™®é€šæ•Œäººï¼šæ— ç‰¹æ•ˆ
                        break;
                }
            }

            // ç»˜åˆ¶å­å¼¹ç²¾çµ
            drawBullet(projectile) {
                if (!projectile.bulletVariant || !this.bulletSpriteLoaded) {
                    // å¦‚æœæ²¡æœ‰ç²¾çµä¿¡æ¯æˆ–å›¾ç‰‡æœªåŠ è½½ï¼Œä½¿ç”¨åœ†å½¢ä½œä¸ºåå¤‡
                    this.ctx.fillStyle = projectile.color;
                    this.ctx.beginPath();
                    this.ctx.arc(projectile.x, projectile.y, projectile.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    return;
                }

                const spriteData = this.sprites[projectile.bulletVariant];
                if (!spriteData) {
                    // å¦‚æœç²¾çµæ•°æ®ä¸å­˜åœ¨ï¼Œä½¿ç”¨åœ†å½¢ä½œä¸ºåå¤‡
                    this.ctx.fillStyle = projectile.color;
                    this.ctx.beginPath();
                    this.ctx.arc(projectile.x, projectile.y, projectile.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    return;
                }

                // è®¡ç®—ç»˜åˆ¶å°ºå¯¸ï¼ˆå­å¼¹æ¯”è¾ƒå°ï¼‰
                const scale = (projectile.radius * 3) / Math.max(spriteData.width, spriteData.height);
                const drawWidth = spriteData.width * scale;
                const drawHeight = spriteData.height * scale;

                // ä¿å­˜å½“å‰å˜æ¢çŠ¶æ€
                this.ctx.save();

                // ç§»åŠ¨åˆ°å­å¼¹ä½ç½®å¹¶æ—‹è½¬ï¼ˆè°ƒæ•´æ–¹å‘ï¼‰
                this.ctx.translate(projectile.x, projectile.y);
                this.ctx.rotate(projectile.angle + Math.PI); // åŠ 180åº¦è°ƒè½¬æ–¹å‘

                // æ·»åŠ å­å¼¹å…‰æ™•æ•ˆæœ
                this.ctx.shadowColor = '#00ffff';
                this.ctx.shadowBlur = 5;

                // ç»˜åˆ¶å­å¼¹ç²¾çµ
                this.ctx.drawImage(
                    this.bulletSprite,
                    spriteData.x, spriteData.y, spriteData.width, spriteData.height,
                    -drawWidth / 2, -drawHeight / 2,
                    drawWidth, drawHeight
                );

                // é‡ç½®é˜´å½±å’Œå˜æ¢
                this.ctx.shadowBlur = 0;
                this.ctx.restore();
            }

            gameLoop() {
                const currentTime = Date.now();
                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;
                
                this.update(deltaTime);
                this.render();
                
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // å¯åŠ¨æ¸¸æˆ
        const game = new DefenseGame();
    </script>
</body>
</html>