<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D é˜²å®ˆæ¸¸æˆ</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #222;
        }
        #gameCanvas {
            display: block;
            background: #1a1a1a;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 5px;
            font-size: 14px;
            border: 2px solid #444;
            z-index: 10;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            display: none;
            border: 2px solid #f00;
            z-index: 1000;
        }
        #gameOver button {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
        }
        #gameOver button:hover {
            background: #45a049;
        }
        .stat-line {
            margin: 5px 0;
        }
        .stat-value {
            color: #0f0;
            font-weight: bold;
        }
        #upgradeMenu {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 5px;
            display: none;
            border: 2px solid #0f0;
            z-index: 100;
        }
        .upgrade-btn {
            margin: 5px;
            padding: 8px 15px;
            cursor: pointer;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 3px;
            font-size: 12px;
        }
        .upgrade-btn:hover {
            background: #45a049;
        }
        .upgrade-btn:disabled {
            background: #666;
            cursor: not-allowed;
        }
        #waveNotice {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff0;
            font-size: 48px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            display: none;
            pointer-events: none;
            z-index: 50;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 600; /* ç¡®ä¿æ§åˆ¶æŒ‰é’®åœ¨æš‚åœé®ç½©ä¹‹ä¸Š */
        }
        .control-btn {
            padding: 10px 20px;
            background: #333;
            color: white;
            border: 2px solid #666;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        .control-btn:hover {
            background: #444;
            border-color: #888;
        }
        .control-btn.active {
            background: #4CAF50;
            border-color: #45a049;
        }
        #difficultyMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px;
            border-radius: 10px;
            border: 2px solid #0f0;
            text-align: center;
            z-index: 1000;
        }
        #difficultyMenu h2 {
            color: white;
            margin-bottom: 20px;
        }
        .difficulty-btn {
            display: block;
            width: 200px;
            margin: 10px auto;
            padding: 15px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        .difficulty-btn:hover {
            background: #45a049;
        }
        .difficulty-desc {
            color: #fcfafa;
            font-size: 13px;
            margin-top: 5px;
        }
        #pauseOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 500; /* åœ¨æ§åˆ¶æŒ‰é’®ä¹‹ä¸‹ */
        }
        #pauseOverlay h2 {
            color: white;
            font-size: 48px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        .ammo-bar {
            margin-top: 10px;
            background: #333;
            height: 20px;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #666;
        }
        .ammo-fill {
            height: 100%;
            background: linear-gradient(to right, #00ff00, #00aa00);
            transition: width 0.3s;
        }
        #skillInfo {
            position: absolute;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 5px;
            display: none;
            border: 2px solid #ff0;
            z-index: 100;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="difficultyMenu" style="height: 80vh; overflow: hidden; display: flex; flex-direction: column;">
        <!-- é¡¶éƒ¨æ ‡é¢˜åŒºåŸŸ -->
        <div style="text-align: center; padding: 20px 0; background: rgba(0,0,0,0.9); color: white;">
            <h1 style="color: #ffff00; margin: 0; font-size: 28px;">ğŸ® æ— é™é˜²å®ˆ</h1>
            <p style="margin: 10px 0 0 0; font-size: 18px;"><strong>ç›®æ ‡ï¼š</strong>åœ¨æ— å°½çš„æ€ªç‰©æ³¢æ¬¡ä¸­ç”Ÿå­˜ä¸‹å»ï¼</p>
        </div>

        <!-- ä¸»è¦å†…å®¹åŒºåŸŸ -->
        <div style="display: flex; flex: 1; overflow: hidden;">
            <!-- å·¦ä¾§ï¼šæ¸¸æˆè¯´æ˜ -->
            <div style="flex: 1; background: rgba(0,0,0,0.8); padding: 15px; color: white; text-align: left; overflow: hidden; border-right: 2px solid #333;">
                <!-- åŒåˆ—å¸ƒå±€å®¹å™¨ -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; height: 100%;">
                    <!-- å·¦åˆ— -->
                    <div>
                        <h3 style="color: #00ff00; font-size: 16px; margin: 0 0 8px 0;">âš”ï¸ æˆ˜æ–—ç³»ç»Ÿ</h3>
                        <ul style="font-size: 14px; margin: 0 0 15px 0; padding-left: 15px;">
                            <li>è‡ªåŠ¨æ”»å‡»èŒƒå›´å†…æœ€è¿‘çš„æ•Œäºº</li>
                            <li>å¼¹è¯æœ‰é™ï¼ŒåŠæ—¶æ¢å¼¹ï¼ˆRé”®ï¼‰</li>
                            <li>æ¯æ³¢ç»“æŸåå‡çº§å±æ€§</li>
                        </ul>

                        <h3 style="color: #ff00ff; font-size: 16px; margin: 0 0 8px 0;">ğŸ¯ æ“ä½œè¯´æ˜</h3>
                        <ul style="font-size: 14px; margin: 0 0 15px 0; padding-left: 15px;">
                            <li><strong>Pé”®</strong> - æš‚åœ/ç»§ç»­</li>
                            <li><strong>Ué”®</strong> - å‡çº§é¢æ¿</li>
                            <li><strong>Ré”®</strong> - æ‰‹åŠ¨æ¢å¼¹</li>
                            <li><strong>å€é€ŸæŒ‰é’®</strong> - 1x/2x/3xé€Ÿåº¦</li>
                        </ul>

                        <h3 style="color: #ffff00; font-size: 16px; margin: 0 0 8px 0;">ï¿½ å‡çº§é™åˆ¶</h3>
                        <ul style="font-size: 14px; margin: 0; padding-left: 15px;">
                            <li><strong>æ”»é€Ÿ</strong> - æœ€å¤š15çº§</li>
                            <li><strong>å­å¼¹æ•°é‡</strong> - æœ€å¤š2çº§</li>
                            <li><strong>å°„ç¨‹</strong> - æœ€å¤š10çº§</li>
                            <li><strong>æ¢å¼¹é€Ÿåº¦</strong> - æœ€å¤š8çº§</li>
                        </ul>
                    </div>

                    <!-- å³åˆ— -->
                    <div>
                        <h3 style="color: #ff8800; font-size: 16px; margin: 0 0 8px 0;">ğŸ‘¹ æ•Œäººç±»å‹</h3>
                        <ul style="font-size: 14px; margin: 0 0 15px 0; padding-left: 15px;">
                            <li><strong>æ™®é€šæ€ª</strong> - åŸºç¡€æ•Œäºº</li>
                            <li><strong>å¿«é€Ÿæ€ª</strong> - é€Ÿåº¦å¿«è¡€é‡å°‘</li>
                            <li><strong>å¦å…‹æ€ª</strong> - è¡€åšç§»åŠ¨æ…¢</li>
                            <li><strong>ç²¾è‹±æ€ª</strong> - æ¯5æ³¢ï¼Œæœ‰ç‰¹æŠ€</li>
                            <li><strong>Boss</strong> - æ¯10æ³¢ï¼Œå¤šç§æŠ€èƒ½</li>
                        </ul>

                        <h3 style="color: #00ffff; font-size: 16px; margin: 0 0 8px 0;">âš¡ Bossç‰¹æŠ€</h3>
                        <ul style="font-size: 14px; margin: 0; padding-left: 15px;">
                            <li><strong>å†²åˆº</strong> - å¿«é€Ÿå†²å‡»</li>
                            <li><strong>å¬å”¤</strong> - å¬å”¤å°æ€ª</li>
                            <li><strong>ç‹‚æš´</strong> - é€Ÿåº¦ä¼¤å®³å¢åŠ </li>
                            <li><strong>æ¿€å…‰</strong> - é«˜ä¼¤å®³å°„çº¿</li>
                            <li><strong>ä¼ é€</strong> - ç¬ç§»æ”»å‡»</li>
                            <li><strong>æŠ¤ç›¾</strong> - å¸æ”¶ä¼¤å®³</li>
                            <li><strong>åœ°éœ‡</strong> - èŒƒå›´æ”»å‡»</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- å³ä¾§ï¼šéš¾åº¦é€‰æ‹© -->
            <div style="flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; background: rgba(0,0,0,0.7); padding: 30px;">
                <h2 style="color: white; margin-bottom: 30px; text-align: center; font-size: 24px;">é€‰æ‹©éš¾åº¦</h2>

                <button class="difficulty-btn" onclick="game.selectDifficulty('kindergarten')" style="margin: 8px 0; width: 280px;">
                    å¹¼å„¿å›­
                    <div class="difficulty-desc">æ•Œäººå¾ˆå¼±ï¼Œèµ„æºä¸°å¯Œ</div>
                </button>
                <button class="difficulty-btn" onclick="game.selectDifficulty('elementary')" style="margin: 8px 0; width: 280px;">
                    å°å­¦ç”Ÿ
                    <div class="difficulty-desc">é€‚åˆæ–°æ‰‹ç»ƒä¹ </div>
                </button>
                <button class="difficulty-btn" onclick="game.selectDifficulty('middle')" style="margin: 8px 0; width: 280px;">
                    åˆä¸­ç”Ÿ
                    <div class="difficulty-desc">æ ‡å‡†éš¾åº¦</div>
                </button>
                <button class="difficulty-btn" onclick="game.selectDifficulty('high')" style="margin: 8px 0; width: 280px;">
                    é«˜ä¸­ç”Ÿ
                    <div class="difficulty-desc">éœ€è¦ä¸€å®šæŠ€å·§</div>
                </button>
                <button class="difficulty-btn" onclick="game.selectDifficulty('university')" style="margin: 8px 0; width: 280px;">
                    å¤§å­¦ç”Ÿ
                    <div class="difficulty-desc">æé™æŒ‘æˆ˜</div>
                </button>
            </div>
        </div>
    </div>
    
    <div id="pauseOverlay">
        <h2>æ¸¸æˆæš‚åœ</h2>
    </div>
    
    <div id="ui">
        <div class="stat-line">éš¾åº¦: <span class="stat-value" id="difficulty">-</span></div>
        <div class="stat-line">æ³¢æ•°: <span class="stat-value" id="wave">1</span></div>
        <div class="stat-line">å‡»æ€æ•°: <span class="stat-value" id="kills">0</span></div>
        <div class="stat-line">é‡‘å¸: <span class="stat-value" id="gold">50</span></div>
        <div class="stat-line">ç»éªŒ: <span class="stat-value" id="exp">0</span> / <span id="expNeeded">50</span></div>
        <div class="stat-line">ç­‰çº§: <span class="stat-value" id="level">1</span></div>
        <hr>
        <div class="stat-line">ç”Ÿå‘½å€¼: <span class="stat-value" id="hp">100</span> / <span id="maxHp">100</span></div>
        <div class="stat-line">æ”»å‡»åŠ›: <span class="stat-value" id="damage">25</span></div>
        <div class="stat-line">æ”»å‡»é€Ÿåº¦: <span class="stat-value" id="attackSpeed">2.0</span>/ç§’</div>
        <div class="stat-line">æ”»å‡»èŒƒå›´: <span class="stat-value" id="range">150</span></div>
        <div class="stat-line">ç”Ÿå‘½å›å¤: <span class="stat-value" id="regen">1</span>/ç§’</div>
        <div class="stat-line">å­å¼¹æ•°é‡: <span class="stat-value" id="bulletCount">1</span></div>
        <div class="stat-line">å¼¹åŒ£å®¹é‡: <span class="stat-value" id="ammo">30</span> / <span id="maxAmmo">30</span></div>
        <div class="ammo-bar">
            <div class="ammo-fill" id="ammoBar" style="width: 100%"></div>
        </div>
    </div>
    
    <div id="controls">
        <button class="control-btn" id="pauseBtn" onclick="game.togglePause()">æš‚åœ (P)</button>
        <button class="control-btn" id="upgradeBtn" onclick="game.toggleUpgradeMenu()">å‡çº§é¢æ¿ (U)</button>
        <button class="control-btn" id="speedBtn" onclick="game.toggleSpeed()">å€é€Ÿ: 1x</button>
    </div>
    
    <div id="upgradeMenu">
        <h3 style="color: white; margin: 0 0 10px 0;">å‡çº§é¢æ¿</h3>
        <button class="upgrade-btn" id="upgradeDamage">æ”»å‡»åŠ› +10 (30é‡‘å¸)</button>
        <button class="upgrade-btn" id="upgradeSpeed">æ”»é€Ÿ +0.5 (25é‡‘å¸)</button>
        <button class="upgrade-btn" id="upgradeHp">ç”Ÿå‘½å€¼ +50 (20é‡‘å¸)</button>
        <button class="upgrade-btn" id="upgradeRange">å°„ç¨‹ +20 (35é‡‘å¸)</button>
        <button class="upgrade-btn" id="upgradeRegen">ç”Ÿå‘½å›å¤ +1 (40é‡‘å¸)</button>
        <button class="upgrade-btn" id="upgradeBullets">å­å¼¹æ•°é‡ +1 (100é‡‘å¸)</button>
        <button class="upgrade-btn" id="upgradeAmmo">å¼¹åŒ£å®¹é‡ +10 (50é‡‘å¸)</button>
        <button class="upgrade-btn" id="upgradeReload">æ¢å¼¹é€Ÿåº¦ +20% (60é‡‘å¸)</button>
    </div>
    
    <div id="skillInfo"></div>
    
    <div id="waveNotice"></div>
    
    <div id="gameOver">
        <h2>æ¸¸æˆç»“æŸï¼</h2>
        <p>éš¾åº¦: <span id="finalDifficulty">-</span></p>
        <p>ä½ åšæŒåˆ°äº†ç¬¬ <span id="finalWave">1</span> æ³¢</p>
        <p>æ€»å‡»æ€æ•°: <span id="finalKills">0</span></p>
        <p>æœ€é«˜ç­‰çº§: <span id="finalLevel">1</span></p>
        <button onclick="location.reload()">é‡æ–°å¼€å§‹</button>
    </div>

    <script>
        class DefenseGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                
                // éš¾åº¦è®¾ç½®
                this.difficulty = null;
                this.difficultySettings = {
                    kindergarten: {
                        name: 'å¹¼å„¿å›­',
                        enemyHpMultiplier: 0.5,
                        enemyDamageMultiplier: 0.5,
                        enemySpeedMultiplier: 0.7,
                        goldMultiplier: 2,
                        expMultiplier: 1.5,
                        startGold: 100
                    },
                    elementary: {
                        name: 'å°å­¦ç”Ÿ',
                        enemyHpMultiplier: 0.75,
                        enemyDamageMultiplier: 0.75,
                        enemySpeedMultiplier: 0.85,
                        goldMultiplier: 1.5,
                        expMultiplier: 1.25,
                        startGold: 75
                    },
                    middle: {
                        name: 'åˆä¸­ç”Ÿ',
                        enemyHpMultiplier: 1,
                        enemyDamageMultiplier: 1,
                        enemySpeedMultiplier: 1,
                        goldMultiplier: 1,
                        expMultiplier: 1,
                        startGold: 50
                    },
                    high: {
                        name: 'é«˜ä¸­ç”Ÿ',
                        enemyHpMultiplier: 1.5,
                        enemyDamageMultiplier: 1.5,
                        enemySpeedMultiplier: 1.2,
                        goldMultiplier: 0.8,
                        expMultiplier: 0.9,
                        startGold: 30
                    },
                    university: {
                        name: 'å¤§å­¦ç”Ÿ',
                        enemyHpMultiplier: 2,
                        enemyDamageMultiplier: 2,
                        enemySpeedMultiplier: 1.5,
                        goldMultiplier: 0.6,
                        expMultiplier: 0.8,
                        startGold: 20
                    }
                };
                
                this.player = {
                    x: this.canvas.width / 2,
                    y: this.canvas.height / 2,
                    radius: 20,
                    hp: 100,
                    maxHp: 100,
                    damage: 25,
                    attackSpeed: 2.0,
                    range: 150,
                    regen: 1,
                    bulletCount: 1,
                    ammo: 30,
                    maxAmmo: 30,
                    reloadSpeed: 2000, // 2ç§’æ¢å¼¹
                    isReloading: false,
                    reloadStartTime: 0,
                    color: '#00ff00',
                    lastAttackTime: 0,
                    lastRegenTime: 0
                };
                
                this.enemies = [];
                this.projectiles = [];
                this.particles = [];
                this.floatingTexts = [];
                
                this.wave = 1;
                this.enemiesInWave = 0;
                this.enemiesSpawned = 0;
                this.kills = 0;
                this.gold = 50;
                this.exp = 0;
                this.level = 1;
                this.expNeeded = 50;
                
                this.isPaused = false;
                this.isGameStarted = false;
                this.isWaveComplete = false;
                this.lastTime = 0;
                this.spawnTimer = 0;
                this.gameSpeed = 1; // æ¸¸æˆå€é€Ÿ
                this.speedOptions = [1, 2, 3]; // å¯é€‰å€é€Ÿ
                this.currentSpeedIndex = 0;
                
                this.upgradeCosts = {
                    damage: 30,
                    attackSpeed: 25,
                    maxHp: 20,
                    range: 35,
                    regen: 40,
                    bulletCount: 100,
                    maxAmmo: 50,
                    reloadSpeed: 60
                };

                // å‡çº§ç­‰çº§è·Ÿè¸ª
                this.upgradeLevels = {
                    damage: 0,
                    attackSpeed: 0,
                    maxHp: 0,
                    range: 0,
                    regen: 0,
                    bulletCount: 0,
                    maxAmmo: 0,
                    reloadSpeed: 0
                };

                // å‡çº§ä¸Šé™è®¾ç½®
                this.upgradeMaxLevels = {
                    damage: 999, // æ”»å‡»åŠ›å¯ä»¥æ— é™å‡çº§
                    attackSpeed: 15, // æ”»é€Ÿæœ€å¤šå‡çº§15æ¬¡
                    maxHp: 999, // ç”Ÿå‘½å€¼å¯ä»¥æ— é™å‡çº§
                    range: 10, // å°„ç¨‹æœ€å¤šå‡çº§10æ¬¡
                    regen: 999, // ç”Ÿå‘½å›å¤å¯ä»¥æ— é™å‡çº§
                    bulletCount: 2, // å­å¼¹æ•°é‡æœ€å¤šå‡çº§2æ¬¡
                    maxAmmo: 999, // å¼¹åŒ£å®¹é‡å¯ä»¥æ— é™å‡çº§
                    reloadSpeed: 8 // æ¢å¼¹é€Ÿåº¦æœ€å¤šå‡çº§8æ¬¡
                };
                
                this.init();
            }
            
            init() {
                // ç»‘å®šå‡çº§æŒ‰é’®
                document.getElementById('upgradeDamage').onclick = () => this.upgradePlayer('damage');
                document.getElementById('upgradeSpeed').onclick = () => this.upgradePlayer('attackSpeed');
                document.getElementById('upgradeHp').onclick = () => this.upgradePlayer('maxHp');
                document.getElementById('upgradeRange').onclick = () => this.upgradePlayer('range');
                document.getElementById('upgradeRegen').onclick = () => this.upgradePlayer('regen');
                document.getElementById('upgradeBullets').onclick = () => this.upgradePlayer('bulletCount');
                document.getElementById('upgradeAmmo').onclick = () => this.upgradePlayer('maxAmmo');
                document.getElementById('upgradeReload').onclick = () => this.upgradePlayer('reloadSpeed');
                
                // é”®ç›˜äº‹ä»¶
                window.addEventListener('keydown', (e) => {
                    if (e.key === 'p' || e.key === 'P') {
                        this.togglePause();
                    } else if (e.key === 'u' || e.key === 'U') {
                        this.toggleUpgradeMenu();
                    } else if (e.key === 'r' || e.key === 'R') {
                        this.reload();
                    }
                });
                
                // ç›‘å¬çª—å£å¤§å°å˜åŒ–
                window.addEventListener('resize', () => {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                    this.player.x = this.canvas.width / 2;
                    this.player.y = this.canvas.height / 2;
                });
                
                // å¼€å§‹æ¸¸æˆå¾ªç¯
                this.gameLoop();
            }
            
            selectDifficulty(difficulty) {
                this.difficulty = difficulty;
                const settings = this.difficultySettings[difficulty];
                this.gold = settings.startGold;
                this.isGameStarted = true;
                
                document.getElementById('difficultyMenu').style.display = 'none';
                document.getElementById('difficulty').textContent = settings.name;
                
                this.startWave();
                this.updateUI();
            }
            
            togglePause() {
                if (!this.isGameStarted) return;

                this.isPaused = !this.isPaused;
                const pauseOverlay = document.getElementById('pauseOverlay');
                const pauseBtn = document.getElementById('pauseBtn');

                if (this.isPaused) {
                    pauseOverlay.style.display = 'flex';
                    pauseBtn.textContent = 'ç»§ç»­ (P)';
                    pauseBtn.classList.add('active');
                } else {
                    pauseOverlay.style.display = 'none';
                    pauseBtn.textContent = 'æš‚åœ (P)';
                    pauseBtn.classList.remove('active');
                }
            }

            toggleSpeed() {
                if (!this.isGameStarted) return;

                this.currentSpeedIndex = (this.currentSpeedIndex + 1) % this.speedOptions.length;
                this.gameSpeed = this.speedOptions[this.currentSpeedIndex];
                document.getElementById('speedBtn').textContent = `å€é€Ÿ: ${this.gameSpeed}x`;
            }
            
            toggleUpgradeMenu() {
                if (!this.isGameStarted) return;
                
                const menu = document.getElementById('upgradeMenu');
                const btn = document.getElementById('upgradeBtn');
                
                if (menu.style.display === 'block') {
                    menu.style.display = 'none';
                    btn.classList.remove('active');
                } else {
                    menu.style.display = 'block';
                    btn.classList.add('active');
                    this.updateUpgradeButtons();
                }
            }
            
            reload() {
                if (this.player.ammo === this.player.maxAmmo || this.player.isReloading) return;
                
                this.player.isReloading = true;
                this.player.reloadStartTime = Date.now();
                
                this.showSkillInfo('æ¢å¼¹ä¸­...');
                
                setTimeout(() => {
                    this.player.ammo = this.player.maxAmmo;
                    this.player.isReloading = false;
                    this.hideSkillInfo();
                }, this.player.reloadSpeed);
            }
            
            showSkillInfo(text) {
                const info = document.getElementById('skillInfo');
                info.textContent = text;
                info.style.display = 'block';
            }
            
            hideSkillInfo() {
                document.getElementById('skillInfo').style.display = 'none';
            }
            
            startWave() {
                this.isWaveComplete = false;
                const config = this.getWaveConfig(this.wave);
                this.enemiesInWave = config.enemyCount;
                this.enemiesSpawned = 0;
                this.spawnTimer = 0;
                
                // æ˜¾ç¤ºæ³¢æ•°æç¤º
                this.showWaveNotice();
                
                // æ³¢æ•°å¥–åŠ±ï¼ˆä»ç¬¬2æ³¢å¼€å§‹ï¼‰
                if (this.wave > 1) {
                    const settings = this.difficultySettings[this.difficulty];
                    const bonus = Math.floor((this.wave - 1) * 15 * settings.goldMultiplier);
                    this.gold += bonus;
                    this.createFloatingText(this.player.x, this.player.y - 50, `+${bonus}é‡‘å¸`, '#ffff00');
                }
            }
            
            showWaveNotice() {
                const notice = document.getElementById('waveNotice');
                notice.textContent = `ç¬¬ ${this.wave} æ³¢`;
                notice.style.display = 'block';
                
                if (this.wave % 10 === 0) {
                    notice.style.color = '#ff0000';
                    notice.textContent += ' - BOSSæ¥è¢­ï¼';
                } else if (this.wave % 5 === 0) {
                    notice.style.color = '#ff00ff';
                    notice.textContent += ' - ç²¾è‹±æ€ªå‡ºç°ï¼';
                }
                
                setTimeout(() => {
                    notice.style.display = 'none';
                }, 2000);
            }
            
            getWaveConfig(wave) {
                // æŒ‡æ•°çº§éš¾åº¦é€’å¢ï¼Œå‰10æ³¢ç›¸å¯¹ç®€å•ï¼Œä¹‹åå¿«é€Ÿå¢é•¿
                const baseCount = wave <= 10 ? 3 + Math.floor(wave * 1.5) : 8 + Math.floor(wave * 3.0);
                const exponentialMultiplier = wave > 10 ? Math.pow(1.15, wave - 10) : 1;

                return {
                    enemyCount: Math.floor(baseCount * exponentialMultiplier * 1.5), // æé«˜50%æ€ªç‰©æ•°é‡
                    spawnDelay: Math.max(200, 1500 - wave * 50), // æ›´å¿«çš„ç”Ÿæˆé€Ÿåº¦
                    enemyHpMultiplier: 1 + (wave - 1) * 0.2 * exponentialMultiplier, // æŒ‡æ•°çº§è¡€é‡å¢é•¿
                    enemyDamageMultiplier: 1 + (wave - 1) * 0.15 * exponentialMultiplier, // æŒ‡æ•°çº§ä¼¤å®³å¢é•¿
                    enemySpeedMultiplier: 1 + Math.min((wave - 1) * 0.08, 1.5), // æ›´é«˜çš„é€Ÿåº¦ä¸Šé™
                    specialChance: Math.min(0.5, wave * 0.05), // æ›´é«˜çš„ç‰¹æ®Šæ€ªç‰©æ¦‚ç‡
                    goldMultiplier: Math.max(0.3, 1 - wave * 0.02), // é‡‘å¸è·å–é€’å‡
                    expMultiplier: Math.max(0.4, 1 - wave * 0.015) // ç»éªŒè·å–é€’å‡
                };
            }
            
            spawnEnemy() {
                const config = this.getWaveConfig(this.wave);
                let type = 'normal';
                
                // å†³å®šæ•Œäººç±»å‹
                if (this.wave % 10 === 0 && this.enemiesSpawned === this.enemiesInWave - 1) {
                    type = 'boss';
                } else if (this.wave % 5 === 0 && this.enemiesSpawned >= this.enemiesInWave - 2) {
                    type = 'elite';
                } else if (Math.random() < config.specialChance) {
                    type = Math.random() < 0.5 ? 'fast' : 'tank';
                }
                
                const enemyStats = this.getEnemyStats(type, config);
                
                // éšæœºç”Ÿæˆä½ç½®ï¼ˆåœ¨å±å¹•è¾¹ç¼˜ï¼‰
                const side = Math.floor(Math.random() * 4);
                let x, y;
                
                switch(side) {
                    case 0: // ä¸Š
                        x = Math.random() * this.canvas.width;
                        y = -20;
                        break;
                    case 1: // å³
                        x = this.canvas.width + 20;
                        y = Math.random() * this.canvas.height;
                        break;
                    case 2: // ä¸‹
                        x = Math.random() * this.canvas.width;
                        y = this.canvas.height + 20;
                        break;
                    case 3: // å·¦
                        x = -20;
                        y = Math.random() * this.canvas.height;
                        break;
                }
                
                const enemy = {
                    x: x,
                    y: y,
                    ...enemyStats,
                    angle: 0
                };
                
                this.enemies.push(enemy);
                this.enemiesSpawned++;
            }
            
            getEnemyStats(type, config) {
                const difficultySettings = this.difficultySettings[this.difficulty];
                
                const baseStats = {
                    normal: {
                        radius: 15,
                        hp: 30,
                        maxHp: 30,
                        damage: 5,
                        speed: 1,
                        color: '#ff0000',
                        goldReward: 10,
                        expReward: 10
                    },
                    fast: {
                        radius: 10,
                        hp: 20,
                        maxHp: 20,
                        damage: 3,
                        speed: 2,
                        color: '#ffff00',
                        goldReward: 15,
                        expReward: 15
                    },
                    tank: {
                        radius: 20,
                        hp: 80,
                        maxHp: 80,
                        damage: 8,
                        speed: 0.5,
                        color: '#8b4513',
                        goldReward: 25,
                        expReward: 20
                    },
                    elite: {
                        radius: 25,
                        hp: 150,
                        maxHp: 150,
                        damage: 12,
                        speed: 0.8,
                        color: '#ff00ff',
                        goldReward: 50,
                        expReward: 40,
                        hasSpecialAbility: true,
                        specialAbilities: ['dash', 'split'],
                        lastSpecialTime: 0,
                        specialCooldown: 3000 // 3ç§’å†·å´
                    },
                    boss: {
                        radius: 35,
                        hp: 500,
                        maxHp: 500,
                        damage: 20,
                        speed: 0.4,
                        color: '#ff0000',
                        goldReward: 150,
                        expReward: 100,
                        hasSpecialAbility: true,
                        specialAbilities: ['dash', 'summon', 'rage', 'laser', 'teleport', 'shield', 'earthquake'],
                        lastSpecialTime: 0,
                        specialCooldown: 3000, // 3ç§’å†·å´
                        isRaging: false,
                        rageEndTime: 0,
                        hasShield: false,
                        shieldEndTime: 0,
                        shieldHp: 0,
                        lastTeleportTime: 0,
                        earthquakeCharging: false,
                        earthquakeStartTime: 0
                    }
                };
                
                const stats = { ...baseStats[type], type: type };
                
                // åº”ç”¨æ³¢æ•°åŠ æˆ
                stats.hp = Math.floor(stats.hp * config.enemyHpMultiplier * difficultySettings.enemyHpMultiplier);
                stats.maxHp = Math.floor(stats.maxHp * config.enemyHpMultiplier * difficultySettings.enemyHpMultiplier);
                stats.damage = Math.floor(stats.damage * config.enemyDamageMultiplier * difficultySettings.enemyDamageMultiplier);
                stats.speed = stats.speed * config.enemySpeedMultiplier * difficultySettings.enemySpeedMultiplier;
                // åº”ç”¨æ³¢æ¬¡é€’å‡çš„é‡‘å¸å’Œç»éªŒå¥–åŠ±
                stats.goldReward = Math.floor(stats.goldReward * difficultySettings.goldMultiplier * config.goldMultiplier);
                stats.expReward = Math.floor(stats.expReward * difficultySettings.expMultiplier * config.expMultiplier);
                
                return stats;
            }
            
            createProjectile(target) {
                if (this.player.ammo <= 0 || this.player.isReloading) {
                    if (!this.player.isReloading) {
                        this.reload();
                    }
                    return;
                }
                
                const baseAngle = Math.atan2(target.y - this.player.y, target.x - this.player.x);
                
                // æ ¹æ®å­å¼¹æ•°é‡åˆ›å»ºå¤šä¸ªæŠ•å°„ç‰©
                for (let i = 0; i < this.player.bulletCount; i++) {
                    let angle = baseAngle;
                    
                    // å¤šå­å¼¹æ•£å°„
                    if (this.player.bulletCount > 1) {
                        const spread = 0.2; // æ•£å°„è§’åº¦
                        const offset = (i - (this.player.bulletCount - 1) / 2) * spread;
                        angle += offset;
                    }
                    
                    this.projectiles.push({
                        x: this.player.x,
                        y: this.player.y,
                        vx: Math.cos(angle) * 10,
                        vy: Math.sin(angle) * 10,
                        damage: this.player.damage,
                        radius: 5,
                        color: '#00ffff',
                        target: target,
                        piercing: this.player.level >= 10 ? 1 : 0
                    });
                }
                
                this.player.ammo--;
                
                // è‡ªåŠ¨æ¢å¼¹
                if (this.player.ammo <= 0) {
                    this.reload();
                }
            }
            
            createParticle(x, y, color, count = 5) {
                for (let i = 0; i < count; i++) {
                    const angle = (Math.PI * 2 / count) * i + Math.random() * 0.5;
                    const speed = 2 + Math.random() * 3;
                    
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        radius: 3,
                        color: color,
                        life: 1.0,
                        decay: 0.02
                    });
                }
            }
            
            createFloatingText(x, y, text, color) {
                this.floatingTexts.push({
                    x: x,
                    y: y,
                    text: text,
                    color: color,
                    vy: -2,
                    life: 1.0
                });
            }
            
            update(deltaTime) {
                if (this.isPaused || !this.isGameStarted) return;

                // åº”ç”¨å€é€Ÿ
                deltaTime *= this.gameSpeed;
                
                // ç”Ÿæˆæ•Œäºº
                if (this.enemiesSpawned < this.enemiesInWave && !this.isWaveComplete) {
                    this.spawnTimer += deltaTime;
                    const config = this.getWaveConfig(this.wave);
                    if (this.spawnTimer >= config.spawnDelay) {
                        this.spawnEnemy();
                        this.spawnTimer = 0;
                    }
                }
                
                // ç©å®¶è‡ªåŠ¨æ”»å‡»
                const currentTime = Date.now();
                const attackInterval = 1000 / this.player.attackSpeed;
                
                if (currentTime - this.player.lastAttackTime >= attackInterval && this.enemies.length > 0 && !this.player.isReloading) {
                    // æ‰¾æœ€è¿‘çš„æ•Œäºº
                    let closestEnemy = null;
                    let closestDist = this.player.range;
                    
                    for (const enemy of this.enemies) {
                        const dist = Math.hypot(enemy.x - this.player.x, enemy.y - this.player.y);
                        if (dist < closestDist) {
                            closestDist = dist;
                            closestEnemy = enemy;
                        }
                    }
                    
                    if (closestEnemy) {
                        this.createProjectile(closestEnemy);
                        this.player.lastAttackTime = currentTime;
                    }
                }
                
                // ç©å®¶ç”Ÿå‘½å›å¤
                if (currentTime - this.player.lastRegenTime >= 1000) {
                    if (this.player.hp < this.player.maxHp) {
                        this.player.hp = Math.min(this.player.hp + this.player.regen, this.player.maxHp);
                        this.player.lastRegenTime = currentTime;
                    }
                }
                
                // æ›´æ–°æ•Œäºº
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];

                    // å¤„ç†ç‰¹æ®Šèƒ½åŠ›
                    if (enemy.hasSpecialAbility) {
                        this.updateEnemySpecialAbilities(enemy, currentTime);
                    }

                    // ç§»åŠ¨å‘ç©å®¶
                    const dx = this.player.x - enemy.x;
                    const dy = this.player.y - enemy.y;
                    const dist = Math.hypot(dx, dy);

                    let moveSpeed = enemy.speed;

                    // Bossç‹‚æš´çŠ¶æ€ä¸‹é€Ÿåº¦ç¿»å€
                    if (enemy.isRaging && currentTime < enemy.rageEndTime) {
                        moveSpeed *= 2;
                        enemy.color = '#ff4444'; // ç‹‚æš´æ—¶é¢œè‰²å˜åŒ–
                    } else if (enemy.type === 'boss') {
                        enemy.color = '#ff0000'; // æ¢å¤åŸè‰²
                        enemy.isRaging = false;
                    }

                    if (dist > 0) {
                        enemy.x += (dx / dist) * moveSpeed;
                        enemy.y += (dy / dist) * moveSpeed;
                        enemy.angle = Math.atan2(dy, dx);
                    }

                    // æ£€æŸ¥ç¢°æ’
                    if (dist < this.player.radius + enemy.radius) {
                        this.damagePlayer(enemy.damage);
                        this.createParticle(enemy.x, enemy.y, enemy.color);
                        this.enemies.splice(i, 1);
                    }
                }
                
                // æ›´æ–°æŠ•å°„ç‰©
                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    const proj = this.projectiles[i];
                    
                    proj.x += proj.vx;
                    proj.y += proj.vy;
                    
                    // æ£€æŸ¥è¾¹ç•Œ
                    if (proj.x < 0 || proj.x > this.canvas.width || 
                        proj.y < 0 || proj.y > this.canvas.height) {
                        this.projectiles.splice(i, 1);
                        continue;
                    }
                    
                    // æ£€æŸ¥ç¢°æ’
                    let hit = false;
                    for (let j = this.enemies.length - 1; j >= 0; j--) {
                        const enemy = this.enemies[j];
                        const dist = Math.hypot(enemy.x - proj.x, enemy.y - proj.y);
                        
                        if (dist < enemy.radius + proj.radius) {
                            this.damageEnemy(enemy, j, proj.damage);
                            hit = true;
                            
                            if (proj.piercing > 0) {
                                proj.piercing--;
                            } else {
                                this.projectiles.splice(i, 1);
                            }
                            break;
                        }
                    }
                }
                
                // æ›´æ–°ç²’å­
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vy += 0.2;
                    particle.life -= particle.decay;
                    
                    if (particle.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
                
                // æ›´æ–°æµ®åŠ¨æ–‡å­—
                for (let i = this.floatingTexts.length - 1; i >= 0; i--) {
                    const text = this.floatingTexts[i];
                    
                    text.y += text.vy;
                    text.life -= 0.02;
                    
                    if (text.life <= 0) {
                        this.floatingTexts.splice(i, 1);
                    }
                }
                
                // æ£€æŸ¥æ³¢æ¬¡å®Œæˆ
                if (this.enemies.length === 0 && this.enemiesSpawned >= this.enemiesInWave && !this.isWaveComplete) {
                    this.isWaveComplete = true;
                    this.showUpgradeMenu();
                    
                    setTimeout(() => {
                        this.hideUpgradeMenu();
                        this.wave++;
                        this.startWave();
                    }, 3000);
                }
                
                this.updateUI();
            }
            
            updateEnemySpecialAbilities(enemy, currentTime) {
                if (currentTime - enemy.lastSpecialTime < enemy.specialCooldown) {
                    return;
                }

                const playerDist = Math.hypot(enemy.x - this.player.x, enemy.y - this.player.y);

                // éšæœºé€‰æ‹©ä¸€ä¸ªç‰¹æŠ€
                const ability = enemy.specialAbilities[Math.floor(Math.random() * enemy.specialAbilities.length)];

                switch(ability) {
                    case 'dash':
                        if (playerDist < 200) {
                            this.enemyDash(enemy);
                            enemy.lastSpecialTime = currentTime;
                        }
                        break;
                    case 'split':
                        if (enemy.hp < enemy.maxHp * 0.5) { // è¡€é‡ä½äº50%æ—¶åˆ†è£‚
                            this.enemySplit(enemy);
                            enemy.lastSpecialTime = currentTime;
                        }
                        break;
                    case 'summon':
                        if (playerDist < 300) {
                            this.enemySummon(enemy);
                            enemy.lastSpecialTime = currentTime;
                        }
                        break;
                    case 'rage':
                        if (enemy.hp < enemy.maxHp * 0.3) { // è¡€é‡ä½äº30%æ—¶ç‹‚æš´
                            this.enemyRage(enemy, currentTime);
                            enemy.lastSpecialTime = currentTime;
                        }
                        break;
                    case 'laser':
                        if (playerDist < 400) {
                            this.enemyLaser(enemy);
                            enemy.lastSpecialTime = currentTime;
                        }
                        break;
                    case 'teleport':
                        if (playerDist < 100 && currentTime - enemy.lastTeleportTime > 8000) {
                            this.enemyTeleport(enemy, currentTime);
                            enemy.lastSpecialTime = currentTime;
                        }
                        break;
                    case 'shield':
                        if (enemy.hp < enemy.maxHp * 0.6 && !enemy.hasShield) {
                            this.enemyShield(enemy, currentTime);
                            enemy.lastSpecialTime = currentTime;
                        }
                        break;
                    case 'earthquake':
                        if (playerDist < 250 && !enemy.earthquakeCharging) {
                            this.enemyEarthquake(enemy, currentTime);
                            enemy.lastSpecialTime = currentTime;
                        }
                        break;
                }
            }

            enemyDash(enemy) {
                // å†²åˆºå‘ç©å®¶
                const dx = this.player.x - enemy.x;
                const dy = this.player.y - enemy.y;
                const dist = Math.hypot(dx, dy);

                if (dist > 0) {
                    const dashDistance = 100;
                    enemy.x += (dx / dist) * dashDistance;
                    enemy.y += (dy / dist) * dashDistance;

                    // å†²åˆºç‰¹æ•ˆ
                    this.createParticle(enemy.x, enemy.y, enemy.color, 15);
                    this.createFloatingText(enemy.x, enemy.y - 30, 'å†²åˆº!', '#ff0000');
                }
            }

            enemySplit(enemy) {
                // åˆ†è£‚æˆä¸¤ä¸ªå°æ€ª
                const splitEnemy1 = {
                    x: enemy.x + 30,
                    y: enemy.y,
                    radius: enemy.radius * 0.7,
                    hp: enemy.hp * 0.6,
                    maxHp: enemy.maxHp * 0.6,
                    damage: enemy.damage * 0.8,
                    speed: enemy.speed * 1.3,
                    color: enemy.color,
                    goldReward: Math.floor(enemy.goldReward * 0.4),
                    expReward: Math.floor(enemy.expReward * 0.4),
                    type: 'split',
                    angle: 0
                };

                const splitEnemy2 = {
                    x: enemy.x - 30,
                    y: enemy.y,
                    radius: enemy.radius * 0.7,
                    hp: enemy.hp * 0.6,
                    maxHp: enemy.maxHp * 0.6,
                    damage: enemy.damage * 0.8,
                    speed: enemy.speed * 1.3,
                    color: enemy.color,
                    goldReward: Math.floor(enemy.goldReward * 0.4),
                    expReward: Math.floor(enemy.expReward * 0.4),
                    type: 'split',
                    angle: 0
                };

                this.enemies.push(splitEnemy1, splitEnemy2);
                this.createFloatingText(enemy.x, enemy.y - 30, 'åˆ†è£‚!', '#ff00ff');

                // ç§»é™¤åŸæ•Œäºº
                const index = this.enemies.indexOf(enemy);
                if (index > -1) {
                    this.enemies.splice(index, 1);
                }
            }

            enemySummon(enemy) {
                // å¬å”¤å°æ€ª
                for (let i = 0; i < 2; i++) {
                    const angle = (Math.PI * 2 / 2) * i;
                    const distance = 50;

                    const summonedEnemy = {
                        x: enemy.x + Math.cos(angle) * distance,
                        y: enemy.y + Math.sin(angle) * distance,
                        radius: 10,
                        hp: 20,
                        maxHp: 20,
                        damage: 3,
                        speed: 1.5,
                        color: '#ffaa00',
                        goldReward: 5,
                        expReward: 5,
                        type: 'summoned',
                        angle: 0
                    };

                    this.enemies.push(summonedEnemy);
                }

                this.createFloatingText(enemy.x, enemy.y - 30, 'å¬å”¤!', '#ffaa00');
                this.createParticle(enemy.x, enemy.y, '#ffaa00', 20);
            }

            enemyRage(enemy, currentTime) {
                // ç‹‚æš´çŠ¶æ€
                enemy.isRaging = true;
                enemy.rageEndTime = currentTime + 5000; // æŒç»­5ç§’
                enemy.damage *= 1.5; // ä¼¤å®³å¢åŠ 50%

                this.createFloatingText(enemy.x, enemy.y - 30, 'ç‹‚æš´!', '#ff0000');
                this.createParticle(enemy.x, enemy.y, '#ff0000', 25);
            }

            enemyLaser(enemy) {
                // æ¿€å…‰æ”»å‡» - å‘ç©å®¶å‘å°„æ¿€å…‰
                const dx = this.player.x - enemy.x;
                const dy = this.player.y - enemy.y;
                const dist = Math.hypot(dx, dy);

                if (dist > 0) {
                    // åˆ›å»ºæ¿€å…‰æŠ•å°„ç‰©
                    const laser = {
                        x: enemy.x,
                        y: enemy.y,
                        vx: (dx / dist) * 12, // æ¿€å…‰é€Ÿåº¦å¾ˆå¿«
                        vy: (dy / dist) * 12,
                        radius: 8,
                        damage: enemy.damage * 2, // æ¿€å…‰ä¼¤å®³æ˜¯æ™®é€šæ”»å‡»çš„2å€
                        color: '#00ffff',
                        piercing: 0,
                        isLaser: true
                    };

                    this.projectiles.push(laser);
                    this.createFloatingText(enemy.x, enemy.y - 30, 'æ¿€å…‰!', '#00ffff');
                    this.createParticle(enemy.x, enemy.y, '#00ffff', 15);
                }
            }

            enemyTeleport(enemy, currentTime) {
                // ä¼ é€åˆ°ç©å®¶é™„è¿‘çš„éšæœºä½ç½®
                const angle = Math.random() * Math.PI * 2;
                const distance = 80 + Math.random() * 40; // è·ç¦»ç©å®¶80-120åƒç´ 

                enemy.x = this.player.x + Math.cos(angle) * distance;
                enemy.y = this.player.y + Math.sin(angle) * distance;

                // ç¡®ä¿ä¸ä¼ é€åˆ°ç”»å¸ƒå¤–
                enemy.x = Math.max(enemy.radius, Math.min(this.canvas.width - enemy.radius, enemy.x));
                enemy.y = Math.max(enemy.radius, Math.min(this.canvas.height - enemy.radius, enemy.y));

                enemy.lastTeleportTime = currentTime;

                this.createFloatingText(enemy.x, enemy.y - 30, 'ä¼ é€!', '#ff00ff');
                this.createParticle(enemy.x, enemy.y, '#ff00ff', 20);
            }

            enemyShield(enemy, currentTime) {
                // æŠ¤ç›¾æŠ€èƒ½ - å¸æ”¶ä¼¤å®³
                enemy.hasShield = true;
                enemy.shieldEndTime = currentTime + 8000; // æŠ¤ç›¾æŒç»­8ç§’
                enemy.shieldHp = enemy.maxHp * 0.3; // æŠ¤ç›¾è¡€é‡ä¸ºæœ€å¤§è¡€é‡çš„30%
                enemy.color = '#00ff00'; // æŠ¤ç›¾çŠ¶æ€ä¸‹å˜ç»¿è‰²

                this.createFloatingText(enemy.x, enemy.y - 30, 'æŠ¤ç›¾!', '#00ff00');
                this.createParticle(enemy.x, enemy.y, '#00ff00', 30);
            }

            enemyEarthquake(enemy, currentTime) {
                // åœ°éœ‡æŠ€èƒ½ - èŒƒå›´ä¼¤å®³
                enemy.earthquakeCharging = true;
                enemy.earthquakeStartTime = currentTime;

                this.createFloatingText(enemy.x, enemy.y - 30, 'è“„åŠ›ä¸­...', '#ffaa00');

                // 2ç§’åé‡Šæ”¾åœ°éœ‡
                setTimeout(() => {
                    if (enemy.earthquakeCharging) {
                        const playerDist = Math.hypot(enemy.x - this.player.x, enemy.y - this.player.y);
                        if (playerDist < 150) { // åœ°éœ‡èŒƒå›´150åƒç´ 
                            this.damagePlayer(enemy.damage * 1.5);
                            this.createFloatingText(this.player.x, this.player.y - 30, 'åœ°éœ‡ä¼¤å®³!', '#ff0000');
                        }

                        // åœ°éœ‡ç‰¹æ•ˆ
                        for (let i = 0; i < 20; i++) {
                            const angle = (Math.PI * 2 / 20) * i;
                            const x = enemy.x + Math.cos(angle) * 100;
                            const y = enemy.y + Math.sin(angle) * 100;
                            this.createParticle(x, y, '#8b4513', 8);
                        }

                        this.createFloatingText(enemy.x, enemy.y - 30, 'åœ°éœ‡!', '#8b4513');
                        enemy.earthquakeCharging = false;
                    }
                }, 2000);
            }

            damageEnemy(enemy, index, damage) {
                let actualDamage = damage;

                // æ£€æŸ¥æŠ¤ç›¾
                if (enemy.hasShield && enemy.shieldHp > 0) {
                    if (enemy.shieldHp >= damage) {
                        enemy.shieldHp -= damage;
                        actualDamage = 0;
                        this.createFloatingText(enemy.x, enemy.y - enemy.radius, `æŠ¤ç›¾-${damage}`, '#00ff00');
                    } else {
                        actualDamage = damage - enemy.shieldHp;
                        this.createFloatingText(enemy.x, enemy.y - enemy.radius, `æŠ¤ç›¾-${enemy.shieldHp}`, '#00ff00');
                        enemy.shieldHp = 0;
                        enemy.hasShield = false;
                        enemy.color = '#ff0000'; // æ¢å¤åŸè‰²
                    }
                }

                if (actualDamage > 0) {
                    enemy.hp -= actualDamage;
                    this.createFloatingText(enemy.x, enemy.y - enemy.radius, `-${actualDamage}`, '#ffff00');
                }

                if (enemy.hp <= 0) {
                    // æ­»äº¡æ•ˆæœ
                    this.createParticle(enemy.x, enemy.y, enemy.color, 10);

                    // å¥–åŠ±
                    this.kills++;
                    this.gold += enemy.goldReward;
                    this.addExp(enemy.expReward);

                    // æ˜¾ç¤ºå¥–åŠ±
                    this.createFloatingText(enemy.x, enemy.y, `+${enemy.goldReward}G`, '#ffff00');

                    this.enemies.splice(index, 1);
                }
            }
            
            damagePlayer(damage) {
                this.player.hp -= damage;
                
                // æ˜¾ç¤ºä¼¤å®³
                this.createFloatingText(this.player.x, this.player.y - 30, `-${damage}`, '#ff0000');
                
                if (this.player.hp <= 0) {
                    this.gameOver();
                }
            }
            
            addExp(amount) {
                this.exp += amount;
                
                while (this.exp >= this.expNeeded) {
                    this.exp -= this.expNeeded;
                    this.level++;
                    this.expNeeded = Math.floor(this.expNeeded * 1.2);
                    
                    // å‡çº§å¥–åŠ±
                    this.player.maxHp += 20;
                    this.player.hp = this.player.maxHp;
                    this.player.damage += 5;
                    this.player.attackSpeed += 0.1;
                    
                    // å‡çº§ç‰¹æ•ˆ
                    this.createParticle(this.player.x, this.player.y, '#00ff00', 20);
                    this.createFloatingText(this.player.x, this.player.y - 50, 'LEVEL UP!', '#00ff00');
                }
            }
            
            upgradePlayer(stat) {
                const cost = this.upgradeCosts[stat];
                const currentLevel = this.upgradeLevels[stat];
                const maxLevel = this.upgradeMaxLevels[stat];

                // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°å‡çº§ä¸Šé™
                if (currentLevel >= maxLevel) {
                    return;
                }

                if (this.gold >= cost) {
                    this.gold -= cost;
                    this.upgradeLevels[stat]++;

                    switch(stat) {
                        case 'damage':
                            this.player.damage += 10;
                            this.upgradeCosts.damage = Math.floor(this.upgradeCosts.damage * 1.3);
                            break;
                        case 'attackSpeed':
                            this.player.attackSpeed += 0.5;
                            this.upgradeCosts.attackSpeed = Math.floor(this.upgradeCosts.attackSpeed * 1.3);
                            break;
                        case 'maxHp':
                            this.player.maxHp += 50;
                            this.player.hp += 50;
                            this.upgradeCosts.maxHp = Math.floor(this.upgradeCosts.maxHp * 1.3);
                            break;
                        case 'range':
                            this.player.range += 20;
                            this.upgradeCosts.range = Math.floor(this.upgradeCosts.range * 1.3);
                            break;
                        case 'regen':
                            this.player.regen += 1;
                            this.upgradeCosts.regen = Math.floor(this.upgradeCosts.regen * 1.3);
                            break;
                        case 'bulletCount':
                            this.player.bulletCount += 1;
                            this.upgradeCosts.bulletCount = Math.floor(this.upgradeCosts.bulletCount * 1.5);
                            break;
                        case 'maxAmmo':
                            this.player.maxAmmo += 10;
                            this.player.ammo += 10;
                            this.upgradeCosts.maxAmmo = Math.floor(this.upgradeCosts.maxAmmo * 1.3);
                            break;
                        case 'reloadSpeed':
                            this.player.reloadSpeed = Math.floor(this.player.reloadSpeed * 0.8);
                            this.upgradeCosts.reloadSpeed = Math.floor(this.upgradeCosts.reloadSpeed * 1.4);
                            break;
                    }

                    this.updateUpgradeButtons();
                    this.updateUI();
                }
            }
            
            showUpgradeMenu() {
                document.getElementById('upgradeMenu').style.display = 'block';
                document.getElementById('upgradeBtn').classList.add('active');
                this.updateUpgradeButtons();
            }
            
            hideUpgradeMenu() {
                document.getElementById('upgradeMenu').style.display = 'none';
                document.getElementById('upgradeBtn').classList.remove('active');
            }
            
            updateUpgradeButtons() {
                // æ›´æ–°æŒ‰é’®æ–‡æœ¬ï¼Œæ˜¾ç¤ºç­‰çº§ä¿¡æ¯
                const damageMaxText = this.upgradeMaxLevels.damage === 999 ? 'âˆ' : this.upgradeMaxLevels.damage;
                const hpMaxText = this.upgradeMaxLevels.maxHp === 999 ? 'âˆ' : this.upgradeMaxLevels.maxHp;
                const regenMaxText = this.upgradeMaxLevels.regen === 999 ? 'âˆ' : this.upgradeMaxLevels.regen;
                const ammoMaxText = this.upgradeMaxLevels.maxAmmo === 999 ? 'âˆ' : this.upgradeMaxLevels.maxAmmo;

                document.getElementById('upgradeDamage').textContent = `æ”»å‡»åŠ› +10 [${this.upgradeLevels.damage}/${damageMaxText}] (${this.upgradeCosts.damage}é‡‘å¸)`;
                document.getElementById('upgradeSpeed').textContent = `æ”»é€Ÿ +0.5 [${this.upgradeLevels.attackSpeed}/${this.upgradeMaxLevels.attackSpeed}] (${this.upgradeCosts.attackSpeed}é‡‘å¸)`;
                document.getElementById('upgradeHp').textContent = `ç”Ÿå‘½å€¼ +50 [${this.upgradeLevels.maxHp}/${hpMaxText}] (${this.upgradeCosts.maxHp}é‡‘å¸)`;
                document.getElementById('upgradeRange').textContent = `å°„ç¨‹ +20 [${this.upgradeLevels.range}/${this.upgradeMaxLevels.range}] (${this.upgradeCosts.range}é‡‘å¸)`;
                document.getElementById('upgradeRegen').textContent = `ç”Ÿå‘½å›å¤ +1 [${this.upgradeLevels.regen}/${regenMaxText}] (${this.upgradeCosts.regen}é‡‘å¸)`;
                document.getElementById('upgradeBullets').textContent = `å­å¼¹æ•°é‡ +1 [${this.upgradeLevels.bulletCount}/${this.upgradeMaxLevels.bulletCount}] (${this.upgradeCosts.bulletCount}é‡‘å¸)`;
                document.getElementById('upgradeAmmo').textContent = `å¼¹åŒ£å®¹é‡ +10 [${this.upgradeLevels.maxAmmo}/${ammoMaxText}] (${this.upgradeCosts.maxAmmo}é‡‘å¸)`;
                document.getElementById('upgradeReload').textContent = `æ¢å¼¹é€Ÿåº¦ +20% [${this.upgradeLevels.reloadSpeed}/${this.upgradeMaxLevels.reloadSpeed}] (${this.upgradeCosts.reloadSpeed}é‡‘å¸)`;

                // æ›´æ–°æŒ‰é’®çŠ¶æ€ - æ£€æŸ¥é‡‘å¸å’Œç­‰çº§ä¸Šé™
                document.getElementById('upgradeDamage').disabled = this.gold < this.upgradeCosts.damage || this.upgradeLevels.damage >= this.upgradeMaxLevels.damage;
                document.getElementById('upgradeSpeed').disabled = this.gold < this.upgradeCosts.attackSpeed || this.upgradeLevels.attackSpeed >= this.upgradeMaxLevels.attackSpeed;
                document.getElementById('upgradeHp').disabled = this.gold < this.upgradeCosts.maxHp || this.upgradeLevels.maxHp >= this.upgradeMaxLevels.maxHp;
                document.getElementById('upgradeRange').disabled = this.gold < this.upgradeCosts.range || this.upgradeLevels.range >= this.upgradeMaxLevels.range;
                document.getElementById('upgradeRegen').disabled = this.gold < this.upgradeCosts.regen || this.upgradeLevels.regen >= this.upgradeMaxLevels.regen;
                document.getElementById('upgradeBullets').disabled = this.gold < this.upgradeCosts.bulletCount || this.upgradeLevels.bulletCount >= this.upgradeMaxLevels.bulletCount;
                document.getElementById('upgradeAmmo').disabled = this.gold < this.upgradeCosts.maxAmmo || this.upgradeLevels.maxAmmo >= this.upgradeMaxLevels.maxAmmo;
                document.getElementById('upgradeReload').disabled = this.gold < this.upgradeCosts.reloadSpeed || this.upgradeLevels.reloadSpeed >= this.upgradeMaxLevels.reloadSpeed;

                // ä¸ºè¾¾åˆ°ä¸Šé™çš„æŒ‰é’®æ·»åŠ ç‰¹æ®Šæ ·å¼
                const buttons = ['upgradeDamage', 'upgradeSpeed', 'upgradeHp', 'upgradeRange', 'upgradeRegen', 'upgradeBullets', 'upgradeAmmo', 'upgradeReload'];
                const stats = ['damage', 'attackSpeed', 'maxHp', 'range', 'regen', 'bulletCount', 'maxAmmo', 'reloadSpeed'];

                buttons.forEach((buttonId, index) => {
                    const button = document.getElementById(buttonId);
                    const stat = stats[index];
                    if (this.upgradeLevels[stat] >= this.upgradeMaxLevels[stat]) {
                        button.style.backgroundColor = '#666';
                        button.style.color = '#999';
                        button.textContent = button.textContent.replace(/\(.*?\)/, '(å·²æ»¡çº§)');
                    } else {
                        button.style.backgroundColor = '';
                        button.style.color = '';
                    }
                });
            }
            
            updateUI() {
                document.getElementById('wave').textContent = this.wave;
                document.getElementById('kills').textContent = this.kills;
                document.getElementById('gold').textContent = this.gold;
                document.getElementById('exp').textContent = this.exp;
                document.getElementById('expNeeded').textContent = this.expNeeded;
                document.getElementById('level').textContent = this.level;
                document.getElementById('hp').textContent = Math.max(0, Math.floor(this.player.hp));
                document.getElementById('maxHp').textContent = this.player.maxHp;
                document.getElementById('damage').textContent = this.player.damage;
                document.getElementById('attackSpeed').textContent = this.player.attackSpeed.toFixed(1);
                document.getElementById('range').textContent = Math.floor(this.player.range);
                document.getElementById('regen').textContent = this.player.regen;
                document.getElementById('bulletCount').textContent = this.player.bulletCount;
                document.getElementById('ammo').textContent = this.player.ammo;
                document.getElementById('maxAmmo').textContent = this.player.maxAmmo;
                
                // æ›´æ–°å¼¹è¯æ¡
                const ammoPercent = this.player.ammo / this.player.maxAmmo;
                document.getElementById('ammoBar').style.width = `${ammoPercent * 100}%`;
            }
            
            gameOver() {
                this.isPaused = true;
                document.getElementById('finalDifficulty').textContent = this.difficultySettings[this.difficulty].name;
                document.getElementById('finalWave').textContent = this.wave;
                document.getElementById('finalKills').textContent = this.kills;
                document.getElementById('finalLevel').textContent = this.level;
                document.getElementById('gameOver').style.display = 'block';
            }
            
            render() {
                // æ¸…ç©ºç”»å¸ƒ
                this.ctx.fillStyle = '#1a1a1a';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                if (!this.isGameStarted) return;
                
                // ç»˜åˆ¶ç½‘æ ¼
                this.drawGrid();
                
                // ç»˜åˆ¶æ”»å‡»èŒƒå›´
                this.ctx.strokeStyle = 'rgba(0, 255, 0, 0.2)';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.arc(this.player.x, this.player.y, this.player.range, 0, Math.PI * 2);
                this.ctx.stroke();
                
                // ç»˜åˆ¶ç©å®¶
                this.ctx.fillStyle = this.player.isReloading ? '#888888' : this.player.color;
                this.ctx.beginPath();
                this.ctx.arc(this.player.x, this.player.y, this.player.radius, 0, Math.PI * 2);
                this.ctx.fill();
                
                // ç»˜åˆ¶ç©å®¶è¡€æ¡
                const hpPercent = this.player.hp / this.player.maxHp;
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(this.player.x - 25, this.player.y - 35, 50, 5);
                this.ctx.fillStyle = hpPercent > 0.5 ? '#0f0' : hpPercent > 0.25 ? '#ff0' : '#f00';
                this.ctx.fillRect(this.player.x - 25, this.player.y - 35, 50 * hpPercent, 5);
                
                // ç»˜åˆ¶æ¢å¼¹è¿›åº¦
                if (this.player.isReloading) {
                    const reloadProgress = (Date.now() - this.player.reloadStartTime) / this.player.reloadSpeed;
                    this.ctx.fillStyle = '#000';
                    this.ctx.fillRect(this.player.x - 25, this.player.y + 30, 50, 3);
                    this.ctx.fillStyle = '#00ffff';
                    this.ctx.fillRect(this.player.x - 25, this.player.y + 30, 50 * reloadProgress, 3);
                }
                
                // ç»˜åˆ¶æ•Œäºº
                for (const enemy of this.enemies) {
                    // æ•Œäººèº«ä½“
                    this.ctx.fillStyle = enemy.color;
                    this.ctx.beginPath();
                    
                    if (enemy.type === 'boss') {
                        // Bossç”¨æ˜Ÿå½¢
                        this.drawStar(enemy.x, enemy.y, enemy.radius, enemy.radius * 0.5, 8);
                    } else if (enemy.type === 'elite') {
                        // ç²¾è‹±ç”¨å…­è¾¹å½¢
                        this.drawPolygon(enemy.x, enemy.y, enemy.radius, 6);
                    } else if (enemy.type === 'tank') {
                        // å¦å…‹ç”¨æ–¹å½¢
                        this.ctx.fillRect(enemy.x - enemy.radius, enemy.y - enemy.radius, enemy.radius * 2, enemy.radius * 2);
                    } else {
                        // æ™®é€šæ•Œäººç”¨åœ†å½¢
                        this.ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
                    }
                    this.ctx.fill();
                    
                    // æ•Œäººè¡€æ¡
                    const enemyHpPercent = enemy.hp / enemy.maxHp;
                    this.ctx.fillStyle = '#000';
                    this.ctx.fillRect(enemy.x - enemy.radius, enemy.y - enemy.radius - 10, enemy.radius * 2, 4);
                    this.ctx.fillStyle = enemyHpPercent > 0.5 ? '#0f0' : enemyHpPercent > 0.25 ? '#ff0' : '#f00';
                    this.ctx.fillRect(enemy.x - enemy.radius, enemy.y - enemy.radius - 10, enemy.radius * 2 * enemyHpPercent, 4);
                }
                
                // ç»˜åˆ¶æŠ•å°„ç‰©
                for (const proj of this.projectiles) {
                    this.ctx.fillStyle = proj.color;
                    this.ctx.beginPath();
                    this.ctx.arc(proj.x, proj.y, proj.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                // ç»˜åˆ¶ç²’å­
                for (const particle of this.particles) {
                    this.ctx.fillStyle = particle.color;
                    this.ctx.globalAlpha = particle.life;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                this.ctx.globalAlpha = 1;
                
                // ç»˜åˆ¶æµ®åŠ¨æ–‡å­—
                for (const text of this.floatingTexts) {
                    this.ctx.fillStyle = text.color;
                    this.ctx.globalAlpha = text.life;
                    this.ctx.font = 'bold 16px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(text.text, text.x, text.y);
                }
                this.ctx.globalAlpha = 1;
            }
            
            drawGrid() {
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                this.ctx.lineWidth = 1;
                
                const gridSize = 50;
                
                for (let x = 0; x < this.canvas.width; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                
                for (let y = 0; y < this.canvas.height; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
            }
            
            drawPolygon(x, y, radius, sides) {
                this.ctx.beginPath();
                for (let i = 0; i < sides; i++) {
                    const angle = (i / sides) * Math.PI * 2 - Math.PI / 2;
                    const px = x + Math.cos(angle) * radius;
                    const py = y + Math.sin(angle) * radius;
                    if (i === 0) {
                        this.ctx.moveTo(px, py);
                    } else {
                        this.ctx.lineTo(px, py);
                    }
                }
                this.ctx.closePath();
            }
            
            drawStar(x, y, outerRadius, innerRadius, points) {
                this.ctx.beginPath();
                for (let i = 0; i < points * 2; i++) {
                    const angle = (i / (points * 2)) * Math.PI * 2 - Math.PI / 2;
                    const radius = i % 2 === 0 ? outerRadius : innerRadius;
                    const px = x + Math.cos(angle) * radius;
                    const py = y + Math.sin(angle) * radius;
                    if (i === 0) {
                        this.ctx.moveTo(px, py);
                    } else {
                        this.ctx.lineTo(px, py);
                    }
                }
                this.ctx.closePath();
            }
            
            gameLoop() {
                const currentTime = Date.now();
                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;
                
                this.update(deltaTime);
                this.render();
                
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // å¯åŠ¨æ¸¸æˆ
        const game = new DefenseGame();
    </script>
</body>
</html>